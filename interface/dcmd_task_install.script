#!/bin/env python
import os
import commands
import shutil
import sys


INSTALL_BASE_PATH="/var/dcmd/"
RESERVE_PACKAGE_NUM = 5


class DcmdInstall():
  def __init__(self):
    #get environ var
    self.svr_pool_ = os.environ.get('DCMD_SVR_POOL')
    self.svr_name_ = os.environ.get('DCMD_SVR_NAME')
    self.svr_version_ = os.environ.get('DCMD_SVR_VERSION')
    self.svr_repo_ = os.environ.get('DCMD_SVR_REPO')
    self.svr_user_ = os.environ.get('DCMD_SVR_USER')
    self.svr_ip_ = os.environ.get('DCMD_SVR_IP')
    self.is_svr_update_env_ = (int)(os.environ.get('DCMD_SVR_UPDATE_ENV'))
    self.is_svr_update_tag_ = (int)(os.environ.get('DCMD_SVR_UPDATE_TAG'))
    self.svr_env_v_ = os.environ.get('DCMD_SVR_ENV_V')
    self.svr_out_file_ = os.environ.get('DCMD_SVR_OUT_FILE')
    self.is_svr_process_ = (int)(os.environ.get('DCMD_SVR_PROCESS'))
    self.svr_package_main_name_ = self.svr_name_ + "_" + self.svr_version_
    self.svr_package_ = self.svr_package_main_name_ + ".tar.gz"
    self.svr_home_ = INSTALL_BASE_PATH + self.svr_name_
    self.svr_package_path_ = os.path.join(self.svr_home_, "package")
    self.svr_running_home_ = os.path.join(self.svr_home_, "running")
    self.svr_version_file_ = os.path.join(self.svr_home_, "version")
    self.svr_back_path_ = os.path.join(self.svr_home_, "back")
    self.svr_back_running_ = os.path.join(self.svr_back_path_, "running")
    self.svr_tmp_path_ = os.path.join(self.svr_home, "tmp")
    self.svr_online_version_ = ""
    self.is_backup_running = False
    self.svr_packages_ = []
    self.install_errmsg_ = ""
    self.install_success_ = False

  #init the service path
  def init_service_env(self):
    print("Check service home:%s" % self.svr_home_)
    self._check_and_mk_missed_path(self.svr_home_)
    print("Check service package path:%s" % self.svr_package_path_)
    self._check_and_mk_missed_path(self.svr_package_path_)
    print("Check service back path:%s" % self.svr_back_path_)
    self._check_and_mk_missed_path(self.svr_back_path_)
    print("Check service tmp path:%s" % self.svr_tmp_path_)
    self._check_and_mk_missed_path(self.svr_tmp_path_)
    print("Remove service backup-running:%s" % self.svr_back_running_)
    self._remove(self.svr_back_running_)
    print("Clear tmp path:%s" % self.svr_tmp_path_)
    package_files = os.listdir(self.svr_tmp_path_)
    for f in package_files:
      rm_file = os.path.join(self.svr_tmp_path_, f)
      self._remove(rm_file)
    print("Remove old package file...............")
    package_files = os.listdir(self.svr_package_path_)
    packages = []
    for f in package_files:
      if os.path.isdir(f):
        rm_file = os.path.join(self.svr_package_path_, f)
        shutil.rmtree(rm_file)
        continue
      statinfo=os.stat(os.path.join(self.svr_package_path_, f))
      packages.append(((int)(statinfo.st_ctime), f))
    packages.sort(lambda x,y:cmp(x[0],y[0]))
    while len(packages) > RESERVE_PACKAGE_NUM:
      self._remove(self.svr_package_path_, packages[0][1])
      del packages[0]
    
  #check current version
  def check_version(self):
    print "Check service [%s]'s version....." % self.svr_name_
    if os.path.isfile(self.svr_version_file_):
      print "Version file exists, file:%s." % self.svr_version_file_
      with open(self.svr_version_file_, 'r') as f:
        self.svr_online_version_ = f.read()
        print "Online version is:%s" % svr_online_version_
        if svr_online_version_ == self.svr_version_:
          print "Version is same, version:%s" % self.svr_version_
          return True
        else:
          print "Version is not same, running version:%s, install version:%s" % (svr_online_version_, self.svr_version_)
          return False
    print "Version file doesn't exist, version file:%s" % self.svr_version_file_
    return False
  
  #create version file to save version
  def create_version_file(self):
    print "Save version[%s] to %s" % (self.svr_version_, self.svr_version_file_)
    with open(self.svr_version_file, 'w') as f:
      f.write(self.svr_version_)
  
  #remove current version file
  def remove_version_file(self):
    print "Remove current verision file:%s" % self.svr_version_file_
    self._remove(self.svr_version_file_)

  #out result to out_file
  def output_result(self):
    if self.install_success_:
      with open(self.svr_out_file_, 'w') as f:
        f.write("state=success\n")
        f.write("errmsg=")
    else:
      with open(self.svr_out_file_, 'w') as f:
        f.write("state=failuer\n")
        f.write("errmsg=%s" % self.install_errmsg_)

  #download service package
  def download_package(self):
    save_file = os.path.join(self.svr_package_path_, self.svr_package_)
    tmp_file = os.path.join(self.svr_tmp_path_, self.svr_package_)
    is_download = True
    if os.path.isfile(save_file):
      if not self.is_svr_update_tag_:
        print "Pachage file:%s exist, doesn't download" % self.svr_package_
        shutil.copyfile(save_file, tmp_file)
        is_download = False
      else:
        self._remove(save_file)
    if is_download:
      if os.path.isfile(tmp_file):
          self._remove(tmp_file)
      download_path_file = self.svr_repo_ + "/" + self.svr_name_ + "/" + self.svr_package_
      print "wget package file:%s" % download_path_file
      wget_cmd = "wget " + download_path_file + " -P " + self.svr_tmp_path_
      if not self._run_cmd(wget_cmd):
        self.install_errmsg_ = "Failure to download package:%s" % download_path_file
        self.install_success_ = False
        return False
      shutil.copy(tmp_file, save_file)
    unzip_cmd = "tar -zxvf " + tmp_file + " -C " + self.svr_tmp_path_
    if not self._run_cmd(unzip_cmd):
      self.install_errmsg_ = "Failure to unpack package:%s" % tmp_file
      self.install_success_ = False
      return False
    tmp_conf_dir = os.path.join(self.svr_tmp_path_, self.svr_package_main_name_)
    if not os.path.isdir(tmp_conf_dir):
      os.mkdir(tmp_conf_dir)
    return True

  #download service config
  def download_config(self):
    return True

  #stop service
  def stop_service(self):
    return True

  #backup running servcie
  def backup_service(self):
    return True

  #move service package to running dir
  def move_package_to_running(self):
    return True

  #install service
  def install_service(self):
    return True

  #start service
  def start_service(self):
    return True

  #remove backup
  def remove_backup(self):
    return True

  #run shell cmd
  def run_cmd(self, command, show=True):
    if show:
      print "==> run command : %s" % (command)
    status, output = commands.getstatusoutput(command)
    if status != 0:
      print "==> failed[%s] : %s" % (status, output)
      return False
    return True


  #copy files or dir
  def copytree(self, src, dst):
    name = []
    if os.path.isdir(src):
      names = os.listdir(src)  
    if not os.path.isdir(dst):
      os.makedirs(dst)
    
    for name in names:
      srcname = os.path.join(src, name)
      dstname = os.path.join(dst, name)  
      try:
        if os.path.isdir(srcname):
          self.copytree(srcname, dstname)  
        else:
          if os.path.isdir(dstname):
            os.rmdir(dstname)
          elif os.path.isfile(dstname):
            os.remove(dstname)
          shutil.copy2(srcname, dstname)
      except (IOError, os.error) as why:
        print "copy %s to %s exception :%s" % (srcname, dstname, str(why))
        return False
        #errors.append((srcname, dstname, str(why)))  
        # catch the Error from the recursive copytree so that we can  
        # continue with other files
      except OSError as err:  
        #errors.extend(err.args[0])
        print "copytree exception :%s" % err.args[0]
        return False
    return True

  #download package
  def download_package(self):
    try:
      check_file = self.save_path + self.svr_package_
      if os.path.isfile(check_file):
        print "==> have this version package:%s, not need download." % check_file
      else:
        #mkdir path
        print "==> need download, make download path : %s" % self.save_path
        self.remove(self.save_path)
        os.makedirs(self.save_path)
        
        wfile = self.app_svn_path + self.app_name + "/" + self.app_bvid
        print "==> begin wget package : %s" % wfile
        wget_cmd = "wget " + wfile + " -P " + self.save_path
        if not self.run_cmd(wget_cmd):
          return False
 
      self.upload_path = self.save_path
      #check whether need unzip
      if self.app_bvid.find(".tar.gz") > 0:
        print "==> need unzip..."
        unzip_file = self.save_path + self.app_bvid[:self.app_bvid.find(".tar.gz")]
        self.remove(unzip_file)
        unzip_cmd = "tar -zxvf " + self.save_path + self.app_bvid + " -C " + self.save_path + " && rm " + self.save_path + self.app_bvid
        if not self.run_cmd(unzip_cmd):
          return False
        if os.path.isdir(unzip_file):
          self.upload_path = unzip_file
    except Exception, e:
      print "==> catch exception :", str(e)
      return False
    return True

  def download_conf(self):
    try:
      if not self.app_env:
        print "==> app environment is not specified. used default conf file!"
        return True
      print "==> download config file!"
      fp = open(self.app_env_file, 'r')
      all_lines = fp.readlines()
      fp.close()
      for line in all_lines:
        line = line.strip()
        items = line.split(' ')
        for item in items:
          config_file_path = item.strip()
          config_file = config_file_path[config_file_path.rfind('/') + 1:]
          dest_file = self.app_path + "/config/" + config_file
          if os.path.isfile(dest_file):
            os.remove(dest_file)
          export_cmd = "wget -c " + item.strip() + " --http-user=guojun8 --http-password=123456 -P " + self.app_path + "/config/"
          if not self.run_cmd(export_cmd):
            return False

    except Exception, e:
      print "==> catch exception :", str(e)
      return False
    return True

  def move_tree(self, src, dest):
    try:
      if src[-1] == '/':
        src = src[0:len(src) - 1]
      if dest[-1] == '/':
        dest = dest[0:len(dest) - 1]
      if os.path.exists(dest):
        shutil.rmtree(dest)
      shutil.move(src, dest)
      return True
    except Exception, e:
      print "==> catch exception : %s" % str(e)
      return False


  #back up original files
  def backup_original(self):
    try: 
      print "==> begin backup backup_path : %s" % self.backup_path
      if os.path.exists(self.app_path):
        print "==> need backup %s to %s" % (self.app_path, self.backup_path)
        if not self.move_tree(self.app_path, self.backup_path):
          return False
    except Exception, e:
      print "==> catch exception : %s" % str(e)
      return False
    return True

  def clean_up(self):
    try:
      app_backup_path = LOCAL_STORE_PATH + self.app_name
      print "==> begin clean_up backup_path : %s" % app_backup_path
      if os.path.exists(app_backup_path):
        remove_cmd = "rm -rf " + app_backup_path + "/*"
        if not self.run_cmd(remove_cmd):
          return False
    except Exception, e:
      print "==> catch exception : %s" % str(e)
      return False
    return True
  
  #stop func, child must release
  def stop_func(self):
    try:
      stop_file = self.app_path + "/bin/scripts/dcmd_stop.sh"
      if not os.path.isfile(stop_file):
        print("==> Warning, Can't find %s" % stop_file)
        return True
      stop_cmd = "sh " + stop_file
      if not self.run_cmd(stop_cmd):
        return False
    except Exception, e:
      print "stop_server failed, catch exception :%s" % str(e)      
      return False
    return True
  
  #stop server
  def stop_server(self):
    global WD_APP_SHELL_PATH
    if self.app_start == "1":
      print "==> need stop server..."
      #stop_cmd = "/bin/sh " + WD_APP_SHELL_PATH + self.app_name + "/stop.sh"
      #print "==> begin stop cmd : %s" % stop_cmd
      if not self.stop_func():
        print "==> call stop func failed"
        return False

    return True

  #install package
  def install_package(self):
    try:
      print "==> begin install package %s to %s" % (self.upload_path, self.app_path)
      #move to dest
      if not self.copytree(self.upload_path, self.app_path):
        return False
    except Exception, e:
      print "install_package catch exception :%s" % str(e)
      return False
    return True

  def check_server(self):
    try:
      check_file = self.app_path + "/bin/scripts/dcmd_check.sh"
      if not os.path.isfile(check_file):
        print("==> Warning, Can't find %s" % check_file)
        return True
      start_cmd = "sh " + check_file
      if not self.run_cmd(start_cmd):
        return False

    except Exception, e:
      print "check_server catch exception : %s" % str(e)
      return False
    return True
  
  #start function , child must relase it
  def start_func(self):
    try:
      start_file = self.app_path + "/bin/scripts/dcmd_start.sh"
      if not os.path.isfile(start_file):
        print("==> Warning, Can't find %s" % start_file)
        return True
      start_cmd = "sh " + start_file + " 1 > /dev/null 2>&1 \&"
      if not self.run_cmd(start_cmd):
        return False
    except Exception, e:
      print "Start_server failed, catch exception :%s" % str(e)      
      return False
    return True
  
  #start server
  def start_server(self):
    if self.app_start == "1":
      print "==> need start server..."
      if not self.start_func():
        return False
    return True
  
  #roll back package
  def rollback(self):
    print "==> begin roll_back code, copy %s to %s" % (self.backup_path, self.app_path)
    #a.copy prv code back
    if not self.copytree(self.backup_path, self.app_path):
      print "==> backup online code failed!"
      return False
    #b.stop server
    if not self.stop_server():
      return False
    #c.start server
    if not self.start_server():
      return False

    if not self.check_server():
      return False
    return True

  #remove file or dir
  def _remove(self, df):
    if os.path.isfile(df):
      os.remove(df)
    elif os.path.isdir(df):
      shutil.rmtree(df)

  #check and create missing subpath
  def _check_and_mk_missed_path(self, path):
    if not os.path.isdir(path):
      os.mkdir(path)

  #runing system cmd
  def _run_cmd(self, cmd):
    ret = os.system(cmd)
    ret >>= 8
    return ret == 0

def main():
  install = DcmdInstall()
  #1.check version
  try:
    print("\nSTEP 0: init svr enviroment.......\n")
    install.init_service_env()

    print("\nSTEP 1: Check version.............\n")
    if install.check_version():
      print "==>The package version to be installed is same as current versionm, install succeed."
      install.install_success_ = True
      install.output_result()
      return

    print("\nSTEP 2: Download package............\n")
    if not install.download_package():
      install.output_result()
      return
      
    print("\nSTEP 3: Download config file.........\n")
    if not install.download_config():
      install.output_result()
      return

    print("\nSTEP 4: Stop current service........\n")
    if not install.stop_service():
      install.output_result()
      return

    print("\STEP 5: Remove version file............\n")
    install.remove_version_file()

    print("\nSTEP 6: Backup running service to back........\n")
    if not install.backup_service():
      install.output_result()
      return

    print("\nSTEP 7: Move service package to running.........\n")
    if not install.move_package_to_running()
      install.output_result()
      return

    print("\nSTEP 8: Install service..............\n")
    if not install.install_service():
      install.output_result()
      return

    print("\nSTEP 9: Start service...............\n")
    if not install.start_service():
      install.output_result()
      return

    print("\nSTEP 10: Remove backup servcie............\n")
    if not install.remove_backup():
      install.output_result()
      return

    print("\nSTEP 11: Create service version file............\n")
    install.create_version_file()

    print("Success to install serivice.\n")
    install.install_success_ = True
  except Exception, e:
    print "Failed to install in step:%d, Exception:%s" % (step, e)
    install.install_errmsg_ = str(e)
    install.install_success_ = False
 
  install.output_result()
  
  
if __name__ == "__main__":
  main()
