// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dcmd.proto

#ifndef PROTOBUF_dcmd_2eproto__INCLUDED
#define PROTOBUF_dcmd_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace dcmd_api {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_dcmd_2eproto();
void protobuf_AssignDesc_dcmd_2eproto();
void protobuf_ShutdownFile_dcmd_2eproto();

class KeyValue;
class SubTaskInfo;
class OprInfo;
class AgentInfo;
class AgentReport;
class AgentReportReply;
class AgentMasterNoticeReply;
class AgentTaskCmd;
class AgentTaskCmdReply;
class AgentSubTaskProcess;
class AgentTaskResult;
class AgentTaskResultReply;
class AgentOprCmd;
class AgentOprCmdReply;
class AgentTaskOutput;
class AgentTaskOutputReply;
class AgentRunningTask;
class AgentRunningTaskReply;
class AgentRunningOpr;
class AgentRunningOprReply;
class InvalidMsg;
class UiTaskOutput;
class UiTaskOutputReply;
class UiAgentRunningTask;
class UiAgentRunningTaskReply;
class UiAgentRunningOpr;
class UiAgentRunningOprReply;
class UiExecOprCmd;
class UiExecOprCmdReply;
class UiAgentInfo;
class UiAgentInfoReply;
class UiInvalidAgentInfo;
class UiInvalidAgentInfoReply;
class UiTaskScriptInfo;
class UiTaskScriptInfoReply;
class UiOprScriptInfo;
class UiOprScriptInfoReply;
class UiAgentTaskProcess;
class UiAgentTaskProcessReply;
class UiTaskCmd;
class UiTaskCmdReply;
class UiTaskWatch;
class UiTaskWatchReply;

enum DcmdState {
  SUCCESS = 0,
  FAILED = 1
};
bool DcmdState_IsValid(int value);
const DcmdState DcmdState_MIN = SUCCESS;
const DcmdState DcmdState_MAX = FAILED;
const int DcmdState_ARRAYSIZE = DcmdState_MAX + 1;

const ::google::protobuf::EnumDescriptor* DcmdState_descriptor();
inline const ::std::string& DcmdState_Name(DcmdState value) {
  return ::google::protobuf::internal::NameOfEnum(
    DcmdState_descriptor(), value);
}
inline bool DcmdState_Parse(
    const ::std::string& name, DcmdState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DcmdState>(
    DcmdState_descriptor(), name, value);
}
enum AgentState {
  AGENT_UN_CONNECTED = 0,
  AGENT_UN_AUTH = 1,
  AGENT_UN_REPORTED = 2,
  AGENT_CONNECTED = 3
};
bool AgentState_IsValid(int value);
const AgentState AgentState_MIN = AGENT_UN_CONNECTED;
const AgentState AgentState_MAX = AGENT_CONNECTED;
const int AgentState_ARRAYSIZE = AgentState_MAX + 1;

const ::google::protobuf::EnumDescriptor* AgentState_descriptor();
inline const ::std::string& AgentState_Name(AgentState value) {
  return ::google::protobuf::internal::NameOfEnum(
    AgentState_descriptor(), value);
}
inline bool AgentState_Parse(
    const ::std::string& name, AgentState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AgentState>(
    AgentState_descriptor(), name, value);
}
enum TaskState {
  TASK_INIT = 0,
  TASK_DOING = 1,
  TASK_PAUSED = 2,
  TASK_FAILED = 3,
  TASK_FREEZED = 4,
  TASK_FINISHED = 5,
  TASK_FINISHED_WITH_FAILED = 6
};
bool TaskState_IsValid(int value);
const TaskState TaskState_MIN = TASK_INIT;
const TaskState TaskState_MAX = TASK_FINISHED_WITH_FAILED;
const int TaskState_ARRAYSIZE = TaskState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskState_descriptor();
inline const ::std::string& TaskState_Name(TaskState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskState_descriptor(), value);
}
inline bool TaskState_Parse(
    const ::std::string& name, TaskState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskState>(
    TaskState_descriptor(), name, value);
}
enum AppPoolState {
  APP_POOL_INIT = 0,
  APP_POOL_DOING = 1,
  APP_POOL_PAUSED = 2,
  APP_POOL_FAILED = 3,
  APP_POOL_FINISHED = 5,
  APP_POOL_FINISHED_WITH_FAILED = 6
};
bool AppPoolState_IsValid(int value);
const AppPoolState AppPoolState_MIN = APP_POOL_INIT;
const AppPoolState AppPoolState_MAX = APP_POOL_FINISHED_WITH_FAILED;
const int AppPoolState_ARRAYSIZE = AppPoolState_MAX + 1;

const ::google::protobuf::EnumDescriptor* AppPoolState_descriptor();
inline const ::std::string& AppPoolState_Name(AppPoolState value) {
  return ::google::protobuf::internal::NameOfEnum(
    AppPoolState_descriptor(), value);
}
inline bool AppPoolState_Parse(
    const ::std::string& name, AppPoolState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AppPoolState>(
    AppPoolState_descriptor(), name, value);
}
enum SubTaskState {
  SUBTASK_INIT = 0,
  SUBTASK_DOING = 1,
  SUBTASK_FINISHED = 2,
  SUBTASK_FAILED = 3,
  SUBTASK_CANCELED = 4
};
bool SubTaskState_IsValid(int value);
const SubTaskState SubTaskState_MIN = SUBTASK_INIT;
const SubTaskState SubTaskState_MAX = SUBTASK_CANCELED;
const int SubTaskState_ARRAYSIZE = SubTaskState_MAX + 1;

const ::google::protobuf::EnumDescriptor* SubTaskState_descriptor();
inline const ::std::string& SubTaskState_Name(SubTaskState value) {
  return ::google::protobuf::internal::NameOfEnum(
    SubTaskState_descriptor(), value);
}
inline bool SubTaskState_Parse(
    const ::std::string& name, SubTaskState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubTaskState>(
    SubTaskState_descriptor(), name, value);
}
enum CmdType {
  START_TASK = 1,
  PAUSE_TASK = 2,
  FINISH_TASK = 3,
  CANCEL_SUBTASK = 4,
  CANCEL_APP_SUBTASK = 5,
  REDO_TASK = 6,
  REDO_APP_POOL = 7,
  REDO_SUBTASK = 8,
  REDO_FAILED_SUBTASK = 9,
  REDO_FAILED_APP_POOL_SUBTASK = 10,
  IGNORE_SUBTASK = 11,
  FREEZE_TASK = 12,
  UNFREEZE_TASK = 13,
  UPDATE_TASK = 14
};
bool CmdType_IsValid(int value);
const CmdType CmdType_MIN = START_TASK;
const CmdType CmdType_MAX = UPDATE_TASK;
const int CmdType_ARRAYSIZE = CmdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CmdType_descriptor();
inline const ::std::string& CmdType_Name(CmdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CmdType_descriptor(), value);
}
inline bool CmdType_Parse(
    const ::std::string& name, CmdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CmdType>(
    CmdType_descriptor(), name, value);
}
// ===================================================================

class KeyValue : public ::google::protobuf::Message {
 public:
  KeyValue();
  virtual ~KeyValue();
  
  KeyValue(const KeyValue& from);
  
  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValue& default_instance();
  
  void Swap(KeyValue* other);
  
  // implements Message ----------------------------------------------
  
  KeyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // required bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.KeyValue)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static KeyValue* default_instance_;
};
// -------------------------------------------------------------------

class SubTaskInfo : public ::google::protobuf::Message {
 public:
  SubTaskInfo();
  virtual ~SubTaskInfo();
  
  SubTaskInfo(const SubTaskInfo& from);
  
  inline SubTaskInfo& operator=(const SubTaskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubTaskInfo& default_instance();
  
  void Swap(SubTaskInfo* other);
  
  // implements Message ----------------------------------------------
  
  SubTaskInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubTaskInfo& from);
  void MergeFrom(const SubTaskInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string app_name = 1;
  inline bool has_app_name() const;
  inline void clear_app_name();
  static const int kAppNameFieldNumber = 1;
  inline const ::std::string& app_name() const;
  inline void set_app_name(const ::std::string& value);
  inline void set_app_name(const char* value);
  inline void set_app_name(const char* value, size_t size);
  inline ::std::string* mutable_app_name();
  inline ::std::string* release_app_name();
  
  // required string task_type = 2;
  inline bool has_task_type() const;
  inline void clear_task_type();
  static const int kTaskTypeFieldNumber = 2;
  inline const ::std::string& task_type() const;
  inline void set_task_type(const ::std::string& value);
  inline void set_task_type(const char* value);
  inline void set_task_type(const char* value, size_t size);
  inline ::std::string* mutable_task_type();
  inline ::std::string* release_task_type();
  
  // required string task_id = 3;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // required string subtask_id = 4;
  inline bool has_subtask_id() const;
  inline void clear_subtask_id();
  static const int kSubtaskIdFieldNumber = 4;
  inline const ::std::string& subtask_id() const;
  inline void set_subtask_id(const ::std::string& value);
  inline void set_subtask_id(const char* value);
  inline void set_subtask_id(const char* value, size_t size);
  inline ::std::string* mutable_subtask_id();
  inline ::std::string* release_subtask_id();
  
  // required string cmd_id = 5;
  inline bool has_cmd_id() const;
  inline void clear_cmd_id();
  static const int kCmdIdFieldNumber = 5;
  inline const ::std::string& cmd_id() const;
  inline void set_cmd_id(const ::std::string& value);
  inline void set_cmd_id(const char* value);
  inline void set_cmd_id(const char* value, size_t size);
  inline ::std::string* mutable_cmd_id();
  inline ::std::string* release_cmd_id();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.SubTaskInfo)
 private:
  inline void set_has_app_name();
  inline void clear_has_app_name();
  inline void set_has_task_type();
  inline void clear_has_task_type();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_subtask_id();
  inline void clear_has_subtask_id();
  inline void set_has_cmd_id();
  inline void clear_has_cmd_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* app_name_;
  ::std::string* task_type_;
  ::std::string* task_id_;
  ::std::string* subtask_id_;
  ::std::string* cmd_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static SubTaskInfo* default_instance_;
};
// -------------------------------------------------------------------

class OprInfo : public ::google::protobuf::Message {
 public:
  OprInfo();
  virtual ~OprInfo();
  
  OprInfo(const OprInfo& from);
  
  inline OprInfo& operator=(const OprInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OprInfo& default_instance();
  
  void Swap(OprInfo* other);
  
  // implements Message ----------------------------------------------
  
  OprInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OprInfo& from);
  void MergeFrom(const OprInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string start_time = 2;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  inline const ::std::string& start_time() const;
  inline void set_start_time(const ::std::string& value);
  inline void set_start_time(const char* value);
  inline void set_start_time(const char* value, size_t size);
  inline ::std::string* mutable_start_time();
  inline ::std::string* release_start_time();
  
  // required int32 running_second = 3;
  inline bool has_running_second() const;
  inline void clear_running_second();
  static const int kRunningSecondFieldNumber = 3;
  inline ::google::protobuf::int32 running_second() const;
  inline void set_running_second(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:dcmd_api.OprInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_running_second();
  inline void clear_has_running_second();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* start_time_;
  ::google::protobuf::int32 running_second_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static OprInfo* default_instance_;
};
// -------------------------------------------------------------------

class AgentInfo : public ::google::protobuf::Message {
 public:
  AgentInfo();
  virtual ~AgentInfo();
  
  AgentInfo(const AgentInfo& from);
  
  inline AgentInfo& operator=(const AgentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentInfo& default_instance();
  
  void Swap(AgentInfo* other);
  
  // implements Message ----------------------------------------------
  
  AgentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentInfo& from);
  void MergeFrom(const AgentInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // required .dcmd_api.AgentState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline dcmd_api::AgentState state() const;
  inline void set_state(dcmd_api::AgentState value);
  
  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // optional string connected_ip = 4;
  inline bool has_connected_ip() const;
  inline void clear_connected_ip();
  static const int kConnectedIpFieldNumber = 4;
  inline const ::std::string& connected_ip() const;
  inline void set_connected_ip(const ::std::string& value);
  inline void set_connected_ip(const char* value);
  inline void set_connected_ip(const char* value, size_t size);
  inline ::std::string* mutable_connected_ip();
  inline ::std::string* release_connected_ip();
  
  // optional string repored_ip = 5;
  inline bool has_repored_ip() const;
  inline void clear_repored_ip();
  static const int kReporedIpFieldNumber = 5;
  inline const ::std::string& repored_ip() const;
  inline void set_repored_ip(const ::std::string& value);
  inline void set_repored_ip(const char* value);
  inline void set_repored_ip(const char* value, size_t size);
  inline ::std::string* mutable_repored_ip();
  inline ::std::string* release_repored_ip();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentInfo)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_connected_ip();
  inline void clear_has_connected_ip();
  inline void set_has_repored_ip();
  inline void clear_has_repored_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_;
  ::std::string* version_;
  ::std::string* connected_ip_;
  ::std::string* repored_ip_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentInfo* default_instance_;
};
// -------------------------------------------------------------------

class AgentReport : public ::google::protobuf::Message {
 public:
  AgentReport();
  virtual ~AgentReport();
  
  AgentReport(const AgentReport& from);
  
  inline AgentReport& operator=(const AgentReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentReport& default_instance();
  
  void Swap(AgentReport* other);
  
  // implements Message ----------------------------------------------
  
  AgentReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentReport& from);
  void MergeFrom(const AgentReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // repeated string agent_ips = 2;
  inline int agent_ips_size() const;
  inline void clear_agent_ips();
  static const int kAgentIpsFieldNumber = 2;
  inline const ::std::string& agent_ips(int index) const;
  inline ::std::string* mutable_agent_ips(int index);
  inline void set_agent_ips(int index, const ::std::string& value);
  inline void set_agent_ips(int index, const char* value);
  inline void set_agent_ips(int index, const char* value, size_t size);
  inline ::std::string* add_agent_ips();
  inline void add_agent_ips(const ::std::string& value);
  inline void add_agent_ips(const char* value);
  inline void add_agent_ips(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& agent_ips() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_agent_ips();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentReport)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> agent_ips_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentReport* default_instance_;
};
// -------------------------------------------------------------------

class AgentReportReply : public ::google::protobuf::Message {
 public:
  AgentReportReply();
  virtual ~AgentReportReply();
  
  AgentReportReply(const AgentReportReply& from);
  
  inline AgentReportReply& operator=(const AgentReportReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentReportReply& default_instance();
  
  void Swap(AgentReportReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentReportReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentReportReply& from);
  void MergeFrom(const AgentReportReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // optional string err = 2;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 2;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // optional int32 heatbeat = 3;
  inline bool has_heatbeat() const;
  inline void clear_heatbeat();
  static const int kHeatbeatFieldNumber = 3;
  inline ::google::protobuf::int32 heatbeat() const;
  inline void set_heatbeat(::google::protobuf::int32 value);
  
  // optional int32 package_size = 4;
  inline bool has_package_size() const;
  inline void clear_package_size();
  static const int kPackageSizeFieldNumber = 4;
  inline ::google::protobuf::int32 package_size() const;
  inline void set_package_size(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentReportReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_err();
  inline void clear_has_err();
  inline void set_has_heatbeat();
  inline void clear_has_heatbeat();
  inline void set_has_package_size();
  inline void clear_has_package_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* err_;
  int state_;
  ::google::protobuf::int32 heatbeat_;
  ::google::protobuf::int32 package_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentReportReply* default_instance_;
};
// -------------------------------------------------------------------

class AgentMasterNoticeReply : public ::google::protobuf::Message {
 public:
  AgentMasterNoticeReply();
  virtual ~AgentMasterNoticeReply();
  
  AgentMasterNoticeReply(const AgentMasterNoticeReply& from);
  
  inline AgentMasterNoticeReply& operator=(const AgentMasterNoticeReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentMasterNoticeReply& default_instance();
  
  void Swap(AgentMasterNoticeReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentMasterNoticeReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentMasterNoticeReply& from);
  void MergeFrom(const AgentMasterNoticeReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string cmd = 1;
  inline int cmd_size() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd(int index) const;
  inline ::std::string* mutable_cmd(int index);
  inline void set_cmd(int index, const ::std::string& value);
  inline void set_cmd(int index, const char* value);
  inline void set_cmd(int index, const char* value, size_t size);
  inline ::std::string* add_cmd();
  inline void add_cmd(const ::std::string& value);
  inline void add_cmd(const char* value);
  inline void add_cmd(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& cmd() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cmd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentMasterNoticeReply)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> cmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentMasterNoticeReply* default_instance_;
};
// -------------------------------------------------------------------

class AgentTaskCmd : public ::google::protobuf::Message {
 public:
  AgentTaskCmd();
  virtual ~AgentTaskCmd();
  
  AgentTaskCmd(const AgentTaskCmd& from);
  
  inline AgentTaskCmd& operator=(const AgentTaskCmd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentTaskCmd& default_instance();
  
  void Swap(AgentTaskCmd* other);
  
  // implements Message ----------------------------------------------
  
  AgentTaskCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentTaskCmd& from);
  void MergeFrom(const AgentTaskCmd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  
  // required string task_type = 2;
  inline bool has_task_type() const;
  inline void clear_task_type();
  static const int kTaskTypeFieldNumber = 2;
  inline const ::std::string& task_type() const;
  inline void set_task_type(const ::std::string& value);
  inline void set_task_type(const char* value);
  inline void set_task_type(const char* value, size_t size);
  inline ::std::string* mutable_task_type();
  inline ::std::string* release_task_type();
  
  // optional string task_id = 3;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // optional string subtask_id = 4;
  inline bool has_subtask_id() const;
  inline void clear_subtask_id();
  static const int kSubtaskIdFieldNumber = 4;
  inline const ::std::string& subtask_id() const;
  inline void set_subtask_id(const ::std::string& value);
  inline void set_subtask_id(const char* value);
  inline void set_subtask_id(const char* value, size_t size);
  inline ::std::string* mutable_subtask_id();
  inline ::std::string* release_subtask_id();
  
  // optional string ip = 5;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 5;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // optional string app_name = 6;
  inline bool has_app_name() const;
  inline void clear_app_name();
  static const int kAppNameFieldNumber = 6;
  inline const ::std::string& app_name() const;
  inline void set_app_name(const ::std::string& value);
  inline void set_app_name(const char* value);
  inline void set_app_name(const char* value, size_t size);
  inline ::std::string* mutable_app_name();
  inline ::std::string* release_app_name();
  
  // optional string app_pool = 7;
  inline bool has_app_pool() const;
  inline void clear_app_pool();
  static const int kAppPoolFieldNumber = 7;
  inline const ::std::string& app_pool() const;
  inline void set_app_pool(const ::std::string& value);
  inline void set_app_pool(const char* value);
  inline void set_app_pool(const char* value, size_t size);
  inline ::std::string* mutable_app_pool();
  inline ::std::string* release_app_pool();
  
  // optional string app_ver = 8;
  inline bool has_app_ver() const;
  inline void clear_app_ver();
  static const int kAppVerFieldNumber = 8;
  inline const ::std::string& app_ver() const;
  inline void set_app_ver(const ::std::string& value);
  inline void set_app_ver(const char* value);
  inline void set_app_ver(const char* value, size_t size);
  inline ::std::string* mutable_app_ver();
  inline ::std::string* release_app_ver();
  
  // optional string app_repo = 9;
  inline bool has_app_repo() const;
  inline void clear_app_repo();
  static const int kAppRepoFieldNumber = 9;
  inline const ::std::string& app_repo() const;
  inline void set_app_repo(const ::std::string& value);
  inline void set_app_repo(const char* value);
  inline void set_app_repo(const char* value, size_t size);
  inline ::std::string* mutable_app_repo();
  inline ::std::string* release_app_repo();
  
  // optional string app_path = 10;
  inline bool has_app_path() const;
  inline void clear_app_path();
  static const int kAppPathFieldNumber = 10;
  inline const ::std::string& app_path() const;
  inline void set_app_path(const ::std::string& value);
  inline void set_app_path(const char* value);
  inline void set_app_path(const char* value, size_t size);
  inline ::std::string* mutable_app_path();
  inline ::std::string* release_app_path();
  
  // optional string app_user = 11;
  inline bool has_app_user() const;
  inline void clear_app_user();
  static const int kAppUserFieldNumber = 11;
  inline const ::std::string& app_user() const;
  inline void set_app_user(const ::std::string& value);
  inline void set_app_user(const char* value);
  inline void set_app_user(const char* value, size_t size);
  inline ::std::string* mutable_app_user();
  inline ::std::string* release_app_user();
  
  // optional string app_env_file = 12;
  inline bool has_app_env_file() const;
  inline void clear_app_env_file();
  static const int kAppEnvFileFieldNumber = 12;
  inline const ::std::string& app_env_file() const;
  inline void set_app_env_file(const ::std::string& value);
  inline void set_app_env_file(const char* value);
  inline void set_app_env_file(const char* value, size_t size);
  inline ::std::string* mutable_app_env_file();
  inline ::std::string* release_app_env_file();
  
  // optional string app_env_ver = 13;
  inline bool has_app_env_ver() const;
  inline void clear_app_env_ver();
  static const int kAppEnvVerFieldNumber = 13;
  inline const ::std::string& app_env_ver() const;
  inline void set_app_env_ver(const ::std::string& value);
  inline void set_app_env_ver(const char* value);
  inline void set_app_env_ver(const char* value, size_t size);
  inline ::std::string* mutable_app_env_ver();
  inline ::std::string* release_app_env_ver();
  
  // optional bool output_process = 14;
  inline bool has_output_process() const;
  inline void clear_output_process();
  static const int kOutputProcessFieldNumber = 14;
  inline bool output_process() const;
  inline void set_output_process(bool value);
  
  // optional bytes script = 15;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 15;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const void* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  
  // repeated .dcmd_api.KeyValue task_arg = 16;
  inline int task_arg_size() const;
  inline void clear_task_arg();
  static const int kTaskArgFieldNumber = 16;
  inline const ::dcmd_api::KeyValue& task_arg(int index) const;
  inline ::dcmd_api::KeyValue* mutable_task_arg(int index);
  inline ::dcmd_api::KeyValue* add_task_arg();
  inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >&
      task_arg() const;
  inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >*
      mutable_task_arg();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentTaskCmd)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_task_type();
  inline void clear_has_task_type();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_subtask_id();
  inline void clear_has_subtask_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_app_name();
  inline void clear_has_app_name();
  inline void set_has_app_pool();
  inline void clear_has_app_pool();
  inline void set_has_app_ver();
  inline void clear_has_app_ver();
  inline void set_has_app_repo();
  inline void clear_has_app_repo();
  inline void set_has_app_path();
  inline void clear_has_app_path();
  inline void set_has_app_user();
  inline void clear_has_app_user();
  inline void set_has_app_env_file();
  inline void clear_has_app_env_file();
  inline void set_has_app_env_ver();
  inline void clear_has_app_env_ver();
  inline void set_has_output_process();
  inline void clear_has_output_process();
  inline void set_has_script();
  inline void clear_has_script();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cmd_;
  ::std::string* task_type_;
  ::std::string* task_id_;
  ::std::string* subtask_id_;
  ::std::string* ip_;
  ::std::string* app_name_;
  ::std::string* app_pool_;
  ::std::string* app_ver_;
  ::std::string* app_repo_;
  ::std::string* app_path_;
  ::std::string* app_user_;
  ::std::string* app_env_file_;
  ::std::string* app_env_ver_;
  ::std::string* script_;
  ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue > task_arg_;
  bool output_process_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentTaskCmd* default_instance_;
};
// -------------------------------------------------------------------

class AgentTaskCmdReply : public ::google::protobuf::Message {
 public:
  AgentTaskCmdReply();
  virtual ~AgentTaskCmdReply();
  
  AgentTaskCmdReply(const AgentTaskCmdReply& from);
  
  inline AgentTaskCmdReply& operator=(const AgentTaskCmdReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentTaskCmdReply& default_instance();
  
  void Swap(AgentTaskCmdReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentTaskCmdReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentTaskCmdReply& from);
  void MergeFrom(const AgentTaskCmdReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentTaskCmdReply)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentTaskCmdReply* default_instance_;
};
// -------------------------------------------------------------------

class AgentSubTaskProcess : public ::google::protobuf::Message {
 public:
  AgentSubTaskProcess();
  virtual ~AgentSubTaskProcess();
  
  AgentSubTaskProcess(const AgentSubTaskProcess& from);
  
  inline AgentSubTaskProcess& operator=(const AgentSubTaskProcess& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentSubTaskProcess& default_instance();
  
  void Swap(AgentSubTaskProcess* other);
  
  // implements Message ----------------------------------------------
  
  AgentSubTaskProcess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentSubTaskProcess& from);
  void MergeFrom(const AgentSubTaskProcess& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // required string subtask_id = 2;
  inline bool has_subtask_id() const;
  inline void clear_subtask_id();
  static const int kSubtaskIdFieldNumber = 2;
  inline const ::std::string& subtask_id() const;
  inline void set_subtask_id(const ::std::string& value);
  inline void set_subtask_id(const char* value);
  inline void set_subtask_id(const char* value, size_t size);
  inline ::std::string* mutable_subtask_id();
  inline ::std::string* release_subtask_id();
  
  // required string process = 3;
  inline bool has_process() const;
  inline void clear_process();
  static const int kProcessFieldNumber = 3;
  inline const ::std::string& process() const;
  inline void set_process(const ::std::string& value);
  inline void set_process(const char* value);
  inline void set_process(const char* value, size_t size);
  inline ::std::string* mutable_process();
  inline ::std::string* release_process();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentSubTaskProcess)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_subtask_id();
  inline void clear_has_subtask_id();
  inline void set_has_process();
  inline void clear_has_process();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* task_id_;
  ::std::string* subtask_id_;
  ::std::string* process_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentSubTaskProcess* default_instance_;
};
// -------------------------------------------------------------------

class AgentTaskResult : public ::google::protobuf::Message {
 public:
  AgentTaskResult();
  virtual ~AgentTaskResult();
  
  AgentTaskResult(const AgentTaskResult& from);
  
  inline AgentTaskResult& operator=(const AgentTaskResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentTaskResult& default_instance();
  
  void Swap(AgentTaskResult* other);
  
  // implements Message ----------------------------------------------
  
  AgentTaskResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentTaskResult& from);
  void MergeFrom(const AgentTaskResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  
  // required string task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // required string subtask_id = 3;
  inline bool has_subtask_id() const;
  inline void clear_subtask_id();
  static const int kSubtaskIdFieldNumber = 3;
  inline const ::std::string& subtask_id() const;
  inline void set_subtask_id(const ::std::string& value);
  inline void set_subtask_id(const char* value);
  inline void set_subtask_id(const char* value, size_t size);
  inline ::std::string* mutable_subtask_id();
  inline ::std::string* release_subtask_id();
  
  // required bool success = 4;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 4;
  inline bool success() const;
  inline void set_success(bool value);
  
  // optional string err = 5;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 5;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // optional string process = 6;
  inline bool has_process() const;
  inline void clear_process();
  static const int kProcessFieldNumber = 6;
  inline const ::std::string& process() const;
  inline void set_process(const ::std::string& value);
  inline void set_process(const char* value);
  inline void set_process(const char* value, size_t size);
  inline ::std::string* mutable_process();
  inline ::std::string* release_process();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentTaskResult)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_subtask_id();
  inline void clear_has_subtask_id();
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_err();
  inline void clear_has_err();
  inline void set_has_process();
  inline void clear_has_process();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cmd_;
  ::std::string* task_id_;
  ::std::string* subtask_id_;
  ::std::string* err_;
  ::std::string* process_;
  bool success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentTaskResult* default_instance_;
};
// -------------------------------------------------------------------

class AgentTaskResultReply : public ::google::protobuf::Message {
 public:
  AgentTaskResultReply();
  virtual ~AgentTaskResultReply();
  
  AgentTaskResultReply(const AgentTaskResultReply& from);
  
  inline AgentTaskResultReply& operator=(const AgentTaskResultReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentTaskResultReply& default_instance();
  
  void Swap(AgentTaskResultReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentTaskResultReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentTaskResultReply& from);
  void MergeFrom(const AgentTaskResultReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentTaskResultReply)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentTaskResultReply* default_instance_;
};
// -------------------------------------------------------------------

class AgentOprCmd : public ::google::protobuf::Message {
 public:
  AgentOprCmd();
  virtual ~AgentOprCmd();
  
  AgentOprCmd(const AgentOprCmd& from);
  
  inline AgentOprCmd& operator=(const AgentOprCmd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentOprCmd& default_instance();
  
  void Swap(AgentOprCmd* other);
  
  // implements Message ----------------------------------------------
  
  AgentOprCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentOprCmd& from);
  void MergeFrom(const AgentOprCmd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string opr_id = 1;
  inline bool has_opr_id() const;
  inline void clear_opr_id();
  static const int kOprIdFieldNumber = 1;
  inline const ::std::string& opr_id() const;
  inline void set_opr_id(const ::std::string& value);
  inline void set_opr_id(const char* value);
  inline void set_opr_id(const char* value, size_t size);
  inline ::std::string* mutable_opr_id();
  inline ::std::string* release_opr_id();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string run_user = 3;
  inline bool has_run_user() const;
  inline void clear_run_user();
  static const int kRunUserFieldNumber = 3;
  inline const ::std::string& run_user() const;
  inline void set_run_user(const ::std::string& value);
  inline void set_run_user(const char* value);
  inline void set_run_user(const char* value, size_t size);
  inline ::std::string* mutable_run_user();
  inline ::std::string* release_run_user();
  
  // required int32 timeout = 4;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 4;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);
  
  // required bytes script = 5;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 5;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const void* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  
  // repeated .dcmd_api.KeyValue args = 6;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 6;
  inline const ::dcmd_api::KeyValue& args(int index) const;
  inline ::dcmd_api::KeyValue* mutable_args(int index);
  inline ::dcmd_api::KeyValue* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentOprCmd)
 private:
  inline void set_has_opr_id();
  inline void clear_has_opr_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_run_user();
  inline void clear_has_run_user();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_script();
  inline void clear_has_script();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* opr_id_;
  ::std::string* name_;
  ::std::string* run_user_;
  ::std::string* script_;
  ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue > args_;
  ::google::protobuf::int32 timeout_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentOprCmd* default_instance_;
};
// -------------------------------------------------------------------

class AgentOprCmdReply : public ::google::protobuf::Message {
 public:
  AgentOprCmdReply();
  virtual ~AgentOprCmdReply();
  
  AgentOprCmdReply(const AgentOprCmdReply& from);
  
  inline AgentOprCmdReply& operator=(const AgentOprCmdReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentOprCmdReply& default_instance();
  
  void Swap(AgentOprCmdReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentOprCmdReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentOprCmdReply& from);
  void MergeFrom(const AgentOprCmdReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // required bytes result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  inline ::std::string* release_result();
  
  // required string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // optional string ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentOprCmdReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_err();
  inline void clear_has_err();
  inline void set_has_ip();
  inline void clear_has_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* result_;
  ::std::string* err_;
  ::std::string* ip_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentOprCmdReply* default_instance_;
};
// -------------------------------------------------------------------

class AgentTaskOutput : public ::google::protobuf::Message {
 public:
  AgentTaskOutput();
  virtual ~AgentTaskOutput();
  
  AgentTaskOutput(const AgentTaskOutput& from);
  
  inline AgentTaskOutput& operator=(const AgentTaskOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentTaskOutput& default_instance();
  
  void Swap(AgentTaskOutput* other);
  
  // implements Message ----------------------------------------------
  
  AgentTaskOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentTaskOutput& from);
  void MergeFrom(const AgentTaskOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string subtask_id = 1;
  inline bool has_subtask_id() const;
  inline void clear_subtask_id();
  static const int kSubtaskIdFieldNumber = 1;
  inline const ::std::string& subtask_id() const;
  inline void set_subtask_id(const ::std::string& value);
  inline void set_subtask_id(const char* value);
  inline void set_subtask_id(const char* value, size_t size);
  inline ::std::string* mutable_subtask_id();
  inline ::std::string* release_subtask_id();
  
  // required int32 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);
  
  // optional string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentTaskOutput)
 private:
  inline void set_has_subtask_id();
  inline void clear_has_subtask_id();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_ip();
  inline void clear_has_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* subtask_id_;
  ::std::string* ip_;
  ::google::protobuf::int32 offset_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentTaskOutput* default_instance_;
};
// -------------------------------------------------------------------

class AgentTaskOutputReply : public ::google::protobuf::Message {
 public:
  AgentTaskOutputReply();
  virtual ~AgentTaskOutputReply();
  
  AgentTaskOutputReply(const AgentTaskOutputReply& from);
  
  inline AgentTaskOutputReply& operator=(const AgentTaskOutputReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentTaskOutputReply& default_instance();
  
  void Swap(AgentTaskOutputReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentTaskOutputReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentTaskOutputReply& from);
  void MergeFrom(const AgentTaskOutputReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // required bytes result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  inline ::std::string* release_result();
  
  // required int32 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);
  
  // optional string err = 4;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 4;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentTaskOutputReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* result_;
  int state_;
  ::google::protobuf::int32 offset_;
  ::std::string* err_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentTaskOutputReply* default_instance_;
};
// -------------------------------------------------------------------

class AgentRunningTask : public ::google::protobuf::Message {
 public:
  AgentRunningTask();
  virtual ~AgentRunningTask();
  
  AgentRunningTask(const AgentRunningTask& from);
  
  inline AgentRunningTask& operator=(const AgentRunningTask& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentRunningTask& default_instance();
  
  void Swap(AgentRunningTask* other);
  
  // implements Message ----------------------------------------------
  
  AgentRunningTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentRunningTask& from);
  void MergeFrom(const AgentRunningTask& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // optional string app_name = 2;
  inline bool has_app_name() const;
  inline void clear_app_name();
  static const int kAppNameFieldNumber = 2;
  inline const ::std::string& app_name() const;
  inline void set_app_name(const ::std::string& value);
  inline void set_app_name(const char* value);
  inline void set_app_name(const char* value, size_t size);
  inline ::std::string* mutable_app_name();
  inline ::std::string* release_app_name();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentRunningTask)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_app_name();
  inline void clear_has_app_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_;
  ::std::string* app_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentRunningTask* default_instance_;
};
// -------------------------------------------------------------------

class AgentRunningTaskReply : public ::google::protobuf::Message {
 public:
  AgentRunningTaskReply();
  virtual ~AgentRunningTaskReply();
  
  AgentRunningTaskReply(const AgentRunningTaskReply& from);
  
  inline AgentRunningTaskReply& operator=(const AgentRunningTaskReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentRunningTaskReply& default_instance();
  
  void Swap(AgentRunningTaskReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentRunningTaskReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentRunningTaskReply& from);
  void MergeFrom(const AgentRunningTaskReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // repeated .dcmd_api.SubTaskInfo result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::dcmd_api::SubTaskInfo& result(int index) const;
  inline ::dcmd_api::SubTaskInfo* mutable_result(int index);
  inline ::dcmd_api::SubTaskInfo* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo >*
      mutable_result();
  
  // optional string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentRunningTaskReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo > result_;
  ::std::string* err_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentRunningTaskReply* default_instance_;
};
// -------------------------------------------------------------------

class AgentRunningOpr : public ::google::protobuf::Message {
 public:
  AgentRunningOpr();
  virtual ~AgentRunningOpr();
  
  AgentRunningOpr(const AgentRunningOpr& from);
  
  inline AgentRunningOpr& operator=(const AgentRunningOpr& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentRunningOpr& default_instance();
  
  void Swap(AgentRunningOpr* other);
  
  // implements Message ----------------------------------------------
  
  AgentRunningOpr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentRunningOpr& from);
  void MergeFrom(const AgentRunningOpr& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentRunningOpr)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentRunningOpr* default_instance_;
};
// -------------------------------------------------------------------

class AgentRunningOprReply : public ::google::protobuf::Message {
 public:
  AgentRunningOprReply();
  virtual ~AgentRunningOprReply();
  
  AgentRunningOprReply(const AgentRunningOprReply& from);
  
  inline AgentRunningOprReply& operator=(const AgentRunningOprReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentRunningOprReply& default_instance();
  
  void Swap(AgentRunningOprReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentRunningOprReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentRunningOprReply& from);
  void MergeFrom(const AgentRunningOprReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // repeated .dcmd_api.OprInfo result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::dcmd_api::OprInfo& result(int index) const;
  inline ::dcmd_api::OprInfo* mutable_result(int index);
  inline ::dcmd_api::OprInfo* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo >*
      mutable_result();
  
  // optional string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentRunningOprReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo > result_;
  ::std::string* err_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static AgentRunningOprReply* default_instance_;
};
// -------------------------------------------------------------------

class InvalidMsg : public ::google::protobuf::Message {
 public:
  InvalidMsg();
  virtual ~InvalidMsg();
  
  InvalidMsg(const InvalidMsg& from);
  
  inline InvalidMsg& operator=(const InvalidMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvalidMsg& default_instance();
  
  void Swap(InvalidMsg* other);
  
  // implements Message ----------------------------------------------
  
  InvalidMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvalidMsg& from);
  void MergeFrom(const InvalidMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 msg_type = 1;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 1;
  inline ::google::protobuf::int32 msg_type() const;
  inline void set_msg_type(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:dcmd_api.InvalidMsg)
 private:
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 msg_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static InvalidMsg* default_instance_;
};
// -------------------------------------------------------------------

class UiTaskOutput : public ::google::protobuf::Message {
 public:
  UiTaskOutput();
  virtual ~UiTaskOutput();
  
  UiTaskOutput(const UiTaskOutput& from);
  
  inline UiTaskOutput& operator=(const UiTaskOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiTaskOutput& default_instance();
  
  void Swap(UiTaskOutput* other);
  
  // implements Message ----------------------------------------------
  
  UiTaskOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiTaskOutput& from);
  void MergeFrom(const UiTaskOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string subtask_id = 1;
  inline bool has_subtask_id() const;
  inline void clear_subtask_id();
  static const int kSubtaskIdFieldNumber = 1;
  inline const ::std::string& subtask_id() const;
  inline void set_subtask_id(const ::std::string& value);
  inline void set_subtask_id(const char* value);
  inline void set_subtask_id(const char* value, size_t size);
  inline ::std::string* mutable_subtask_id();
  inline ::std::string* release_subtask_id();
  
  // required string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // required int32 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);
  
  // required string user = 4;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 4;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  
  // required string passwd = 5;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 5;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiTaskOutput)
 private:
  inline void set_has_subtask_id();
  inline void clear_has_subtask_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* subtask_id_;
  ::std::string* ip_;
  ::std::string* user_;
  ::std::string* passwd_;
  ::google::protobuf::int32 offset_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiTaskOutput* default_instance_;
};
// -------------------------------------------------------------------

class UiTaskOutputReply : public ::google::protobuf::Message {
 public:
  UiTaskOutputReply();
  virtual ~UiTaskOutputReply();
  
  UiTaskOutputReply(const UiTaskOutputReply& from);
  
  inline UiTaskOutputReply& operator=(const UiTaskOutputReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiTaskOutputReply& default_instance();
  
  void Swap(UiTaskOutputReply* other);
  
  // implements Message ----------------------------------------------
  
  UiTaskOutputReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiTaskOutputReply& from);
  void MergeFrom(const UiTaskOutputReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // required bytes result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  inline ::std::string* release_result();
  
  // required int32 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);
  
  // optional string err = 4;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 4;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiTaskOutputReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* result_;
  int state_;
  ::google::protobuf::int32 offset_;
  ::std::string* err_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiTaskOutputReply* default_instance_;
};
// -------------------------------------------------------------------

class UiAgentRunningTask : public ::google::protobuf::Message {
 public:
  UiAgentRunningTask();
  virtual ~UiAgentRunningTask();
  
  UiAgentRunningTask(const UiAgentRunningTask& from);
  
  inline UiAgentRunningTask& operator=(const UiAgentRunningTask& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiAgentRunningTask& default_instance();
  
  void Swap(UiAgentRunningTask* other);
  
  // implements Message ----------------------------------------------
  
  UiAgentRunningTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiAgentRunningTask& from);
  void MergeFrom(const UiAgentRunningTask& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // optional string app_name = 2;
  inline bool has_app_name() const;
  inline void clear_app_name();
  static const int kAppNameFieldNumber = 2;
  inline const ::std::string& app_name() const;
  inline void set_app_name(const ::std::string& value);
  inline void set_app_name(const char* value);
  inline void set_app_name(const char* value, size_t size);
  inline ::std::string* mutable_app_name();
  inline ::std::string* release_app_name();
  
  // required string user = 3;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 3;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  
  // required string passwd = 4;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 4;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiAgentRunningTask)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_app_name();
  inline void clear_has_app_name();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_;
  ::std::string* app_name_;
  ::std::string* user_;
  ::std::string* passwd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiAgentRunningTask* default_instance_;
};
// -------------------------------------------------------------------

class UiAgentRunningTaskReply : public ::google::protobuf::Message {
 public:
  UiAgentRunningTaskReply();
  virtual ~UiAgentRunningTaskReply();
  
  UiAgentRunningTaskReply(const UiAgentRunningTaskReply& from);
  
  inline UiAgentRunningTaskReply& operator=(const UiAgentRunningTaskReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiAgentRunningTaskReply& default_instance();
  
  void Swap(UiAgentRunningTaskReply* other);
  
  // implements Message ----------------------------------------------
  
  UiAgentRunningTaskReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiAgentRunningTaskReply& from);
  void MergeFrom(const UiAgentRunningTaskReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // repeated .dcmd_api.SubTaskInfo result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::dcmd_api::SubTaskInfo& result(int index) const;
  inline ::dcmd_api::SubTaskInfo* mutable_result(int index);
  inline ::dcmd_api::SubTaskInfo* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo >*
      mutable_result();
  
  // optional string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiAgentRunningTaskReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo > result_;
  ::std::string* err_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiAgentRunningTaskReply* default_instance_;
};
// -------------------------------------------------------------------

class UiAgentRunningOpr : public ::google::protobuf::Message {
 public:
  UiAgentRunningOpr();
  virtual ~UiAgentRunningOpr();
  
  UiAgentRunningOpr(const UiAgentRunningOpr& from);
  
  inline UiAgentRunningOpr& operator=(const UiAgentRunningOpr& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiAgentRunningOpr& default_instance();
  
  void Swap(UiAgentRunningOpr* other);
  
  // implements Message ----------------------------------------------
  
  UiAgentRunningOpr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiAgentRunningOpr& from);
  void MergeFrom(const UiAgentRunningOpr& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // required string user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  
  // required string passwd = 3;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 3;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiAgentRunningOpr)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_;
  ::std::string* user_;
  ::std::string* passwd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiAgentRunningOpr* default_instance_;
};
// -------------------------------------------------------------------

class UiAgentRunningOprReply : public ::google::protobuf::Message {
 public:
  UiAgentRunningOprReply();
  virtual ~UiAgentRunningOprReply();
  
  UiAgentRunningOprReply(const UiAgentRunningOprReply& from);
  
  inline UiAgentRunningOprReply& operator=(const UiAgentRunningOprReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiAgentRunningOprReply& default_instance();
  
  void Swap(UiAgentRunningOprReply* other);
  
  // implements Message ----------------------------------------------
  
  UiAgentRunningOprReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiAgentRunningOprReply& from);
  void MergeFrom(const UiAgentRunningOprReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // repeated .dcmd_api.OprInfo result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::dcmd_api::OprInfo& result(int index) const;
  inline ::dcmd_api::OprInfo* mutable_result(int index);
  inline ::dcmd_api::OprInfo* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo >*
      mutable_result();
  
  // optional string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiAgentRunningOprReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo > result_;
  ::std::string* err_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiAgentRunningOprReply* default_instance_;
};
// -------------------------------------------------------------------

class UiExecOprCmd : public ::google::protobuf::Message {
 public:
  UiExecOprCmd();
  virtual ~UiExecOprCmd();
  
  UiExecOprCmd(const UiExecOprCmd& from);
  
  inline UiExecOprCmd& operator=(const UiExecOprCmd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiExecOprCmd& default_instance();
  
  void Swap(UiExecOprCmd* other);
  
  // implements Message ----------------------------------------------
  
  UiExecOprCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiExecOprCmd& from);
  void MergeFrom(const UiExecOprCmd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string opr_id = 1;
  inline bool has_opr_id() const;
  inline void clear_opr_id();
  static const int kOprIdFieldNumber = 1;
  inline const ::std::string& opr_id() const;
  inline void set_opr_id(const ::std::string& value);
  inline void set_opr_id(const char* value);
  inline void set_opr_id(const char* value, size_t size);
  inline ::std::string* mutable_opr_id();
  inline ::std::string* release_opr_id();
  
  // required string user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  
  // required string passwd = 3;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 3;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiExecOprCmd)
 private:
  inline void set_has_opr_id();
  inline void clear_has_opr_id();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* opr_id_;
  ::std::string* user_;
  ::std::string* passwd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiExecOprCmd* default_instance_;
};
// -------------------------------------------------------------------

class UiExecOprCmdReply : public ::google::protobuf::Message {
 public:
  UiExecOprCmdReply();
  virtual ~UiExecOprCmdReply();
  
  UiExecOprCmdReply(const UiExecOprCmdReply& from);
  
  inline UiExecOprCmdReply& operator=(const UiExecOprCmdReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiExecOprCmdReply& default_instance();
  
  void Swap(UiExecOprCmdReply* other);
  
  // implements Message ----------------------------------------------
  
  UiExecOprCmdReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiExecOprCmdReply& from);
  void MergeFrom(const UiExecOprCmdReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // repeated .dcmd_api.AgentOprCmdReply result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::dcmd_api::AgentOprCmdReply& result(int index) const;
  inline ::dcmd_api::AgentOprCmdReply* mutable_result(int index);
  inline ::dcmd_api::AgentOprCmdReply* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::AgentOprCmdReply >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::AgentOprCmdReply >*
      mutable_result();
  
  // optional string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiExecOprCmdReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dcmd_api::AgentOprCmdReply > result_;
  ::std::string* err_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiExecOprCmdReply* default_instance_;
};
// -------------------------------------------------------------------

class UiAgentInfo : public ::google::protobuf::Message {
 public:
  UiAgentInfo();
  virtual ~UiAgentInfo();
  
  UiAgentInfo(const UiAgentInfo& from);
  
  inline UiAgentInfo& operator=(const UiAgentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiAgentInfo& default_instance();
  
  void Swap(UiAgentInfo* other);
  
  // implements Message ----------------------------------------------
  
  UiAgentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiAgentInfo& from);
  void MergeFrom(const UiAgentInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string ips = 1;
  inline int ips_size() const;
  inline void clear_ips();
  static const int kIpsFieldNumber = 1;
  inline const ::std::string& ips(int index) const;
  inline ::std::string* mutable_ips(int index);
  inline void set_ips(int index, const ::std::string& value);
  inline void set_ips(int index, const char* value);
  inline void set_ips(int index, const char* value, size_t size);
  inline ::std::string* add_ips();
  inline void add_ips(const ::std::string& value);
  inline void add_ips(const char* value);
  inline void add_ips(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ips() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ips();
  
  // required bool version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline bool version() const;
  inline void set_version(bool value);
  
  // required string user = 3;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 3;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  
  // required string passwd = 4;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 4;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiAgentInfo)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> ips_;
  ::std::string* user_;
  ::std::string* passwd_;
  bool version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiAgentInfo* default_instance_;
};
// -------------------------------------------------------------------

class UiAgentInfoReply : public ::google::protobuf::Message {
 public:
  UiAgentInfoReply();
  virtual ~UiAgentInfoReply();
  
  UiAgentInfoReply(const UiAgentInfoReply& from);
  
  inline UiAgentInfoReply& operator=(const UiAgentInfoReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiAgentInfoReply& default_instance();
  
  void Swap(UiAgentInfoReply* other);
  
  // implements Message ----------------------------------------------
  
  UiAgentInfoReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiAgentInfoReply& from);
  void MergeFrom(const UiAgentInfoReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // repeated .dcmd_api.AgentInfo agentinfo = 2;
  inline int agentinfo_size() const;
  inline void clear_agentinfo();
  static const int kAgentinfoFieldNumber = 2;
  inline const ::dcmd_api::AgentInfo& agentinfo(int index) const;
  inline ::dcmd_api::AgentInfo* mutable_agentinfo(int index);
  inline ::dcmd_api::AgentInfo* add_agentinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::AgentInfo >&
      agentinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::AgentInfo >*
      mutable_agentinfo();
  
  // optional string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiAgentInfoReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dcmd_api::AgentInfo > agentinfo_;
  ::std::string* err_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiAgentInfoReply* default_instance_;
};
// -------------------------------------------------------------------

class UiInvalidAgentInfo : public ::google::protobuf::Message {
 public:
  UiInvalidAgentInfo();
  virtual ~UiInvalidAgentInfo();
  
  UiInvalidAgentInfo(const UiInvalidAgentInfo& from);
  
  inline UiInvalidAgentInfo& operator=(const UiInvalidAgentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiInvalidAgentInfo& default_instance();
  
  void Swap(UiInvalidAgentInfo* other);
  
  // implements Message ----------------------------------------------
  
  UiInvalidAgentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiInvalidAgentInfo& from);
  void MergeFrom(const UiInvalidAgentInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  
  // required string passwd = 2;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 2;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiInvalidAgentInfo)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* user_;
  ::std::string* passwd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiInvalidAgentInfo* default_instance_;
};
// -------------------------------------------------------------------

class UiInvalidAgentInfoReply : public ::google::protobuf::Message {
 public:
  UiInvalidAgentInfoReply();
  virtual ~UiInvalidAgentInfoReply();
  
  UiInvalidAgentInfoReply(const UiInvalidAgentInfoReply& from);
  
  inline UiInvalidAgentInfoReply& operator=(const UiInvalidAgentInfoReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiInvalidAgentInfoReply& default_instance();
  
  void Swap(UiInvalidAgentInfoReply* other);
  
  // implements Message ----------------------------------------------
  
  UiInvalidAgentInfoReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiInvalidAgentInfoReply& from);
  void MergeFrom(const UiInvalidAgentInfoReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // required .dcmd_api.AgentInfo agentinfo = 2;
  inline bool has_agentinfo() const;
  inline void clear_agentinfo();
  static const int kAgentinfoFieldNumber = 2;
  inline const ::dcmd_api::AgentInfo& agentinfo() const;
  inline ::dcmd_api::AgentInfo* mutable_agentinfo();
  inline ::dcmd_api::AgentInfo* release_agentinfo();
  
  // optional string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiInvalidAgentInfoReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_agentinfo();
  inline void clear_has_agentinfo();
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::dcmd_api::AgentInfo* agentinfo_;
  ::std::string* err_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiInvalidAgentInfoReply* default_instance_;
};
// -------------------------------------------------------------------

class UiTaskScriptInfo : public ::google::protobuf::Message {
 public:
  UiTaskScriptInfo();
  virtual ~UiTaskScriptInfo();
  
  UiTaskScriptInfo(const UiTaskScriptInfo& from);
  
  inline UiTaskScriptInfo& operator=(const UiTaskScriptInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiTaskScriptInfo& default_instance();
  
  void Swap(UiTaskScriptInfo* other);
  
  // implements Message ----------------------------------------------
  
  UiTaskScriptInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiTaskScriptInfo& from);
  void MergeFrom(const UiTaskScriptInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string task_type = 1;
  inline bool has_task_type() const;
  inline void clear_task_type();
  static const int kTaskTypeFieldNumber = 1;
  inline const ::std::string& task_type() const;
  inline void set_task_type(const ::std::string& value);
  inline void set_task_type(const char* value);
  inline void set_task_type(const char* value, size_t size);
  inline ::std::string* mutable_task_type();
  inline ::std::string* release_task_type();
  
  // required string user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  
  // required string passwd = 3;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 3;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiTaskScriptInfo)
 private:
  inline void set_has_task_type();
  inline void clear_has_task_type();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* task_type_;
  ::std::string* user_;
  ::std::string* passwd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiTaskScriptInfo* default_instance_;
};
// -------------------------------------------------------------------

class UiTaskScriptInfoReply : public ::google::protobuf::Message {
 public:
  UiTaskScriptInfoReply();
  virtual ~UiTaskScriptInfoReply();
  
  UiTaskScriptInfoReply(const UiTaskScriptInfoReply& from);
  
  inline UiTaskScriptInfoReply& operator=(const UiTaskScriptInfoReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiTaskScriptInfoReply& default_instance();
  
  void Swap(UiTaskScriptInfoReply* other);
  
  // implements Message ----------------------------------------------
  
  UiTaskScriptInfoReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiTaskScriptInfoReply& from);
  void MergeFrom(const UiTaskScriptInfoReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // optional string script = 2;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 2;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const char* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  
  // optional string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // optional string md5 = 4;
  inline bool has_md5() const;
  inline void clear_md5();
  static const int kMd5FieldNumber = 4;
  inline const ::std::string& md5() const;
  inline void set_md5(const ::std::string& value);
  inline void set_md5(const char* value);
  inline void set_md5(const char* value, size_t size);
  inline ::std::string* mutable_md5();
  inline ::std::string* release_md5();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiTaskScriptInfoReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_script();
  inline void clear_has_script();
  inline void set_has_err();
  inline void clear_has_err();
  inline void set_has_md5();
  inline void clear_has_md5();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* script_;
  ::std::string* err_;
  ::std::string* md5_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiTaskScriptInfoReply* default_instance_;
};
// -------------------------------------------------------------------

class UiOprScriptInfo : public ::google::protobuf::Message {
 public:
  UiOprScriptInfo();
  virtual ~UiOprScriptInfo();
  
  UiOprScriptInfo(const UiOprScriptInfo& from);
  
  inline UiOprScriptInfo& operator=(const UiOprScriptInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiOprScriptInfo& default_instance();
  
  void Swap(UiOprScriptInfo* other);
  
  // implements Message ----------------------------------------------
  
  UiOprScriptInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiOprScriptInfo& from);
  void MergeFrom(const UiOprScriptInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string opr_file = 1;
  inline bool has_opr_file() const;
  inline void clear_opr_file();
  static const int kOprFileFieldNumber = 1;
  inline const ::std::string& opr_file() const;
  inline void set_opr_file(const ::std::string& value);
  inline void set_opr_file(const char* value);
  inline void set_opr_file(const char* value, size_t size);
  inline ::std::string* mutable_opr_file();
  inline ::std::string* release_opr_file();
  
  // required string user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  
  // required string passwd = 3;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 3;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiOprScriptInfo)
 private:
  inline void set_has_opr_file();
  inline void clear_has_opr_file();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* opr_file_;
  ::std::string* user_;
  ::std::string* passwd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiOprScriptInfo* default_instance_;
};
// -------------------------------------------------------------------

class UiOprScriptInfoReply : public ::google::protobuf::Message {
 public:
  UiOprScriptInfoReply();
  virtual ~UiOprScriptInfoReply();
  
  UiOprScriptInfoReply(const UiOprScriptInfoReply& from);
  
  inline UiOprScriptInfoReply& operator=(const UiOprScriptInfoReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiOprScriptInfoReply& default_instance();
  
  void Swap(UiOprScriptInfoReply* other);
  
  // implements Message ----------------------------------------------
  
  UiOprScriptInfoReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiOprScriptInfoReply& from);
  void MergeFrom(const UiOprScriptInfoReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // optional string script = 2;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 2;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const char* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  
  // optional string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // optional string md5 = 4;
  inline bool has_md5() const;
  inline void clear_md5();
  static const int kMd5FieldNumber = 4;
  inline const ::std::string& md5() const;
  inline void set_md5(const ::std::string& value);
  inline void set_md5(const char* value);
  inline void set_md5(const char* value, size_t size);
  inline ::std::string* mutable_md5();
  inline ::std::string* release_md5();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiOprScriptInfoReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_script();
  inline void clear_has_script();
  inline void set_has_err();
  inline void clear_has_err();
  inline void set_has_md5();
  inline void clear_has_md5();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* script_;
  ::std::string* err_;
  ::std::string* md5_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiOprScriptInfoReply* default_instance_;
};
// -------------------------------------------------------------------

class UiAgentTaskProcess : public ::google::protobuf::Message {
 public:
  UiAgentTaskProcess();
  virtual ~UiAgentTaskProcess();
  
  UiAgentTaskProcess(const UiAgentTaskProcess& from);
  
  inline UiAgentTaskProcess& operator=(const UiAgentTaskProcess& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiAgentTaskProcess& default_instance();
  
  void Swap(UiAgentTaskProcess* other);
  
  // implements Message ----------------------------------------------
  
  UiAgentTaskProcess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiAgentTaskProcess& from);
  void MergeFrom(const UiAgentTaskProcess& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string subtask_id = 1;
  inline int subtask_id_size() const;
  inline void clear_subtask_id();
  static const int kSubtaskIdFieldNumber = 1;
  inline const ::std::string& subtask_id(int index) const;
  inline ::std::string* mutable_subtask_id(int index);
  inline void set_subtask_id(int index, const ::std::string& value);
  inline void set_subtask_id(int index, const char* value);
  inline void set_subtask_id(int index, const char* value, size_t size);
  inline ::std::string* add_subtask_id();
  inline void add_subtask_id(const ::std::string& value);
  inline void add_subtask_id(const char* value);
  inline void add_subtask_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& subtask_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_subtask_id();
  
  // required string user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  
  // required string passwd = 3;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 3;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiAgentTaskProcess)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> subtask_id_;
  ::std::string* user_;
  ::std::string* passwd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiAgentTaskProcess* default_instance_;
};
// -------------------------------------------------------------------

class UiAgentTaskProcessReply : public ::google::protobuf::Message {
 public:
  UiAgentTaskProcessReply();
  virtual ~UiAgentTaskProcessReply();
  
  UiAgentTaskProcessReply(const UiAgentTaskProcessReply& from);
  
  inline UiAgentTaskProcessReply& operator=(const UiAgentTaskProcessReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiAgentTaskProcessReply& default_instance();
  
  void Swap(UiAgentTaskProcessReply* other);
  
  // implements Message ----------------------------------------------
  
  UiAgentTaskProcessReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiAgentTaskProcessReply& from);
  void MergeFrom(const UiAgentTaskProcessReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // repeated string process = 2;
  inline int process_size() const;
  inline void clear_process();
  static const int kProcessFieldNumber = 2;
  inline const ::std::string& process(int index) const;
  inline ::std::string* mutable_process(int index);
  inline void set_process(int index, const ::std::string& value);
  inline void set_process(int index, const char* value);
  inline void set_process(int index, const char* value, size_t size);
  inline ::std::string* add_process();
  inline void add_process(const ::std::string& value);
  inline void add_process(const char* value);
  inline void add_process(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& process() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_process();
  
  // optional string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiAgentTaskProcessReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> process_;
  ::std::string* err_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiAgentTaskProcessReply* default_instance_;
};
// -------------------------------------------------------------------

class UiTaskCmd : public ::google::protobuf::Message {
 public:
  UiTaskCmd();
  virtual ~UiTaskCmd();
  
  UiTaskCmd(const UiTaskCmd& from);
  
  inline UiTaskCmd& operator=(const UiTaskCmd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiTaskCmd& default_instance();
  
  void Swap(UiTaskCmd* other);
  
  // implements Message ----------------------------------------------
  
  UiTaskCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiTaskCmd& from);
  void MergeFrom(const UiTaskCmd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // optional string subtask_id = 2;
  inline bool has_subtask_id() const;
  inline void clear_subtask_id();
  static const int kSubtaskIdFieldNumber = 2;
  inline const ::std::string& subtask_id() const;
  inline void set_subtask_id(const ::std::string& value);
  inline void set_subtask_id(const char* value);
  inline void set_subtask_id(const char* value, size_t size);
  inline ::std::string* mutable_subtask_id();
  inline ::std::string* release_subtask_id();
  
  // optional string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // optional string app_pool = 4;
  inline bool has_app_pool() const;
  inline void clear_app_pool();
  static const int kAppPoolFieldNumber = 4;
  inline const ::std::string& app_pool() const;
  inline void set_app_pool(const ::std::string& value);
  inline void set_app_pool(const char* value);
  inline void set_app_pool(const char* value, size_t size);
  inline ::std::string* mutable_app_pool();
  inline ::std::string* release_app_pool();
  
  // required .dcmd_api.CmdType cmd_type = 5;
  inline bool has_cmd_type() const;
  inline void clear_cmd_type();
  static const int kCmdTypeFieldNumber = 5;
  inline dcmd_api::CmdType cmd_type() const;
  inline void set_cmd_type(dcmd_api::CmdType value);
  
  // required string user = 6;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 6;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  
  // required string passwd = 7;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 7;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiTaskCmd)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_subtask_id();
  inline void clear_has_subtask_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_app_pool();
  inline void clear_has_app_pool();
  inline void set_has_cmd_type();
  inline void clear_has_cmd_type();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* task_id_;
  ::std::string* subtask_id_;
  ::std::string* ip_;
  ::std::string* app_pool_;
  ::std::string* user_;
  ::std::string* passwd_;
  int cmd_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiTaskCmd* default_instance_;
};
// -------------------------------------------------------------------

class UiTaskCmdReply : public ::google::protobuf::Message {
 public:
  UiTaskCmdReply();
  virtual ~UiTaskCmdReply();
  
  UiTaskCmdReply(const UiTaskCmdReply& from);
  
  inline UiTaskCmdReply& operator=(const UiTaskCmdReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiTaskCmdReply& default_instance();
  
  void Swap(UiTaskCmdReply* other);
  
  // implements Message ----------------------------------------------
  
  UiTaskCmdReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiTaskCmdReply& from);
  void MergeFrom(const UiTaskCmdReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // optional string cmd_id = 2;
  inline bool has_cmd_id() const;
  inline void clear_cmd_id();
  static const int kCmdIdFieldNumber = 2;
  inline const ::std::string& cmd_id() const;
  inline void set_cmd_id(const ::std::string& value);
  inline void set_cmd_id(const char* value);
  inline void set_cmd_id(const char* value, size_t size);
  inline ::std::string* mutable_cmd_id();
  inline ::std::string* release_cmd_id();
  
  // optional string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiTaskCmdReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_cmd_id();
  inline void clear_has_cmd_id();
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cmd_id_;
  ::std::string* err_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiTaskCmdReply* default_instance_;
};
// -------------------------------------------------------------------

class UiTaskWatch : public ::google::protobuf::Message {
 public:
  UiTaskWatch();
  virtual ~UiTaskWatch();
  
  UiTaskWatch(const UiTaskWatch& from);
  
  inline UiTaskWatch& operator=(const UiTaskWatch& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiTaskWatch& default_instance();
  
  void Swap(UiTaskWatch* other);
  
  // implements Message ----------------------------------------------
  
  UiTaskWatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiTaskWatch& from);
  void MergeFrom(const UiTaskWatch& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // optional string app_pool = 2;
  inline bool has_app_pool() const;
  inline void clear_app_pool();
  static const int kAppPoolFieldNumber = 2;
  inline const ::std::string& app_pool() const;
  inline void set_app_pool(const ::std::string& value);
  inline void set_app_pool(const char* value);
  inline void set_app_pool(const char* value, size_t size);
  inline ::std::string* mutable_app_pool();
  inline ::std::string* release_app_pool();
  
  // optional string subtask_id = 3;
  inline bool has_subtask_id() const;
  inline void clear_subtask_id();
  static const int kSubtaskIdFieldNumber = 3;
  inline const ::std::string& subtask_id() const;
  inline void set_subtask_id(const ::std::string& value);
  inline void set_subtask_id(const char* value);
  inline void set_subtask_id(const char* value, size_t size);
  inline ::std::string* mutable_subtask_id();
  inline ::std::string* release_subtask_id();
  
  // required string user = 4;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 4;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  
  // required string passwd = 5;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 5;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiTaskWatch)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_app_pool();
  inline void clear_has_app_pool();
  inline void set_has_subtask_id();
  inline void clear_has_subtask_id();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* task_id_;
  ::std::string* app_pool_;
  ::std::string* subtask_id_;
  ::std::string* user_;
  ::std::string* passwd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiTaskWatch* default_instance_;
};
// -------------------------------------------------------------------

class UiTaskWatchReply : public ::google::protobuf::Message {
 public:
  UiTaskWatchReply();
  virtual ~UiTaskWatchReply();
  
  UiTaskWatchReply(const UiTaskWatchReply& from);
  
  inline UiTaskWatchReply& operator=(const UiTaskWatchReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UiTaskWatchReply& default_instance();
  
  void Swap(UiTaskWatchReply* other);
  
  // implements Message ----------------------------------------------
  
  UiTaskWatchReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UiTaskWatchReply& from);
  void MergeFrom(const UiTaskWatchReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState watch_state = 1;
  inline bool has_watch_state() const;
  inline void clear_watch_state();
  static const int kWatchStateFieldNumber = 1;
  inline dcmd_api::DcmdState watch_state() const;
  inline void set_watch_state(dcmd_api::DcmdState value);
  
  // optional string err = 2;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 2;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // optional .dcmd_api.TaskState task_state = 3;
  inline bool has_task_state() const;
  inline void clear_task_state();
  static const int kTaskStateFieldNumber = 3;
  inline dcmd_api::TaskState task_state() const;
  inline void set_task_state(dcmd_api::TaskState value);
  
  // optional .dcmd_api.AppPoolState app_pool_state = 4;
  inline bool has_app_pool_state() const;
  inline void clear_app_pool_state();
  static const int kAppPoolStateFieldNumber = 4;
  inline dcmd_api::AppPoolState app_pool_state() const;
  inline void set_app_pool_state(dcmd_api::AppPoolState value);
  
  // optional .dcmd_api.SubTaskState subtask_state = 5;
  inline bool has_subtask_state() const;
  inline void clear_subtask_state();
  static const int kSubtaskStateFieldNumber = 5;
  inline dcmd_api::SubTaskState subtask_state() const;
  inline void set_subtask_state(dcmd_api::SubTaskState value);
  
  // optional int32 success_subtask = 6;
  inline bool has_success_subtask() const;
  inline void clear_success_subtask();
  static const int kSuccessSubtaskFieldNumber = 6;
  inline ::google::protobuf::int32 success_subtask() const;
  inline void set_success_subtask(::google::protobuf::int32 value);
  
  // optional int32 failed_subtask = 7;
  inline bool has_failed_subtask() const;
  inline void clear_failed_subtask();
  static const int kFailedSubtaskFieldNumber = 7;
  inline ::google::protobuf::int32 failed_subtask() const;
  inline void set_failed_subtask(::google::protobuf::int32 value);
  
  // optional int32 doing_subtask = 8;
  inline bool has_doing_subtask() const;
  inline void clear_doing_subtask();
  static const int kDoingSubtaskFieldNumber = 8;
  inline ::google::protobuf::int32 doing_subtask() const;
  inline void set_doing_subtask(::google::protobuf::int32 value);
  
  // optional int32 cancel_subtask = 9;
  inline bool has_cancel_subtask() const;
  inline void clear_cancel_subtask();
  static const int kCancelSubtaskFieldNumber = 9;
  inline ::google::protobuf::int32 cancel_subtask() const;
  inline void set_cancel_subtask(::google::protobuf::int32 value);
  
  // optional int32 undo_subtask = 10;
  inline bool has_undo_subtask() const;
  inline void clear_undo_subtask();
  static const int kUndoSubtaskFieldNumber = 10;
  inline ::google::protobuf::int32 undo_subtask() const;
  inline void set_undo_subtask(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:dcmd_api.UiTaskWatchReply)
 private:
  inline void set_has_watch_state();
  inline void clear_has_watch_state();
  inline void set_has_err();
  inline void clear_has_err();
  inline void set_has_task_state();
  inline void clear_has_task_state();
  inline void set_has_app_pool_state();
  inline void clear_has_app_pool_state();
  inline void set_has_subtask_state();
  inline void clear_has_subtask_state();
  inline void set_has_success_subtask();
  inline void clear_has_success_subtask();
  inline void set_has_failed_subtask();
  inline void clear_has_failed_subtask();
  inline void set_has_doing_subtask();
  inline void clear_has_doing_subtask();
  inline void set_has_cancel_subtask();
  inline void clear_has_cancel_subtask();
  inline void set_has_undo_subtask();
  inline void clear_has_undo_subtask();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* err_;
  int watch_state_;
  int task_state_;
  int app_pool_state_;
  int subtask_state_;
  ::google::protobuf::int32 success_subtask_;
  ::google::protobuf::int32 failed_subtask_;
  ::google::protobuf::int32 doing_subtask_;
  ::google::protobuf::int32 cancel_subtask_;
  ::google::protobuf::int32 undo_subtask_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_2eproto();
  friend void protobuf_AssignDesc_dcmd_2eproto();
  friend void protobuf_ShutdownFile_dcmd_2eproto();
  
  void InitAsDefaultInstance();
  static UiTaskWatchReply* default_instance_;
};
// ===================================================================


// ===================================================================

// KeyValue

// required string key = 1;
inline bool KeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyValue::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& KeyValue::key() const {
  return *key_;
}
inline void KeyValue::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void KeyValue::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void KeyValue::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyValue::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* KeyValue::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes value = 2;
inline bool KeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyValue::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& KeyValue::value() const {
  return *value_;
}
inline void KeyValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void KeyValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void KeyValue::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* KeyValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SubTaskInfo

// required string app_name = 1;
inline bool SubTaskInfo::has_app_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubTaskInfo::set_has_app_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubTaskInfo::clear_has_app_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubTaskInfo::clear_app_name() {
  if (app_name_ != &::google::protobuf::internal::kEmptyString) {
    app_name_->clear();
  }
  clear_has_app_name();
}
inline const ::std::string& SubTaskInfo::app_name() const {
  return *app_name_;
}
inline void SubTaskInfo::set_app_name(const ::std::string& value) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(value);
}
inline void SubTaskInfo::set_app_name(const char* value) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(value);
}
inline void SubTaskInfo::set_app_name(const char* value, size_t size) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubTaskInfo::mutable_app_name() {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  return app_name_;
}
inline ::std::string* SubTaskInfo::release_app_name() {
  clear_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_name_;
    app_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string task_type = 2;
inline bool SubTaskInfo::has_task_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubTaskInfo::set_has_task_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubTaskInfo::clear_has_task_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubTaskInfo::clear_task_type() {
  if (task_type_ != &::google::protobuf::internal::kEmptyString) {
    task_type_->clear();
  }
  clear_has_task_type();
}
inline const ::std::string& SubTaskInfo::task_type() const {
  return *task_type_;
}
inline void SubTaskInfo::set_task_type(const ::std::string& value) {
  set_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    task_type_ = new ::std::string;
  }
  task_type_->assign(value);
}
inline void SubTaskInfo::set_task_type(const char* value) {
  set_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    task_type_ = new ::std::string;
  }
  task_type_->assign(value);
}
inline void SubTaskInfo::set_task_type(const char* value, size_t size) {
  set_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    task_type_ = new ::std::string;
  }
  task_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubTaskInfo::mutable_task_type() {
  set_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    task_type_ = new ::std::string;
  }
  return task_type_;
}
inline ::std::string* SubTaskInfo::release_task_type() {
  clear_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_type_;
    task_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string task_id = 3;
inline bool SubTaskInfo::has_task_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubTaskInfo::set_has_task_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubTaskInfo::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubTaskInfo::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& SubTaskInfo::task_id() const {
  return *task_id_;
}
inline void SubTaskInfo::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void SubTaskInfo::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void SubTaskInfo::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubTaskInfo::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* SubTaskInfo::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string subtask_id = 4;
inline bool SubTaskInfo::has_subtask_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubTaskInfo::set_has_subtask_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubTaskInfo::clear_has_subtask_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubTaskInfo::clear_subtask_id() {
  if (subtask_id_ != &::google::protobuf::internal::kEmptyString) {
    subtask_id_->clear();
  }
  clear_has_subtask_id();
}
inline const ::std::string& SubTaskInfo::subtask_id() const {
  return *subtask_id_;
}
inline void SubTaskInfo::set_subtask_id(const ::std::string& value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void SubTaskInfo::set_subtask_id(const char* value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void SubTaskInfo::set_subtask_id(const char* value, size_t size) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubTaskInfo::mutable_subtask_id() {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  return subtask_id_;
}
inline ::std::string* SubTaskInfo::release_subtask_id() {
  clear_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtask_id_;
    subtask_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string cmd_id = 5;
inline bool SubTaskInfo::has_cmd_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubTaskInfo::set_has_cmd_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubTaskInfo::clear_has_cmd_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubTaskInfo::clear_cmd_id() {
  if (cmd_id_ != &::google::protobuf::internal::kEmptyString) {
    cmd_id_->clear();
  }
  clear_has_cmd_id();
}
inline const ::std::string& SubTaskInfo::cmd_id() const {
  return *cmd_id_;
}
inline void SubTaskInfo::set_cmd_id(const ::std::string& value) {
  set_has_cmd_id();
  if (cmd_id_ == &::google::protobuf::internal::kEmptyString) {
    cmd_id_ = new ::std::string;
  }
  cmd_id_->assign(value);
}
inline void SubTaskInfo::set_cmd_id(const char* value) {
  set_has_cmd_id();
  if (cmd_id_ == &::google::protobuf::internal::kEmptyString) {
    cmd_id_ = new ::std::string;
  }
  cmd_id_->assign(value);
}
inline void SubTaskInfo::set_cmd_id(const char* value, size_t size) {
  set_has_cmd_id();
  if (cmd_id_ == &::google::protobuf::internal::kEmptyString) {
    cmd_id_ = new ::std::string;
  }
  cmd_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubTaskInfo::mutable_cmd_id() {
  set_has_cmd_id();
  if (cmd_id_ == &::google::protobuf::internal::kEmptyString) {
    cmd_id_ = new ::std::string;
  }
  return cmd_id_;
}
inline ::std::string* SubTaskInfo::release_cmd_id() {
  clear_has_cmd_id();
  if (cmd_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_id_;
    cmd_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OprInfo

// required string name = 1;
inline bool OprInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OprInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OprInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OprInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& OprInfo::name() const {
  return *name_;
}
inline void OprInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OprInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OprInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OprInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* OprInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string start_time = 2;
inline bool OprInfo::has_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OprInfo::set_has_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OprInfo::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OprInfo::clear_start_time() {
  if (start_time_ != &::google::protobuf::internal::kEmptyString) {
    start_time_->clear();
  }
  clear_has_start_time();
}
inline const ::std::string& OprInfo::start_time() const {
  return *start_time_;
}
inline void OprInfo::set_start_time(const ::std::string& value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
}
inline void OprInfo::set_start_time(const char* value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
}
inline void OprInfo::set_start_time(const char* value, size_t size) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OprInfo::mutable_start_time() {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  return start_time_;
}
inline ::std::string* OprInfo::release_start_time() {
  clear_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = start_time_;
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 running_second = 3;
inline bool OprInfo::has_running_second() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OprInfo::set_has_running_second() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OprInfo::clear_has_running_second() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OprInfo::clear_running_second() {
  running_second_ = 0;
  clear_has_running_second();
}
inline ::google::protobuf::int32 OprInfo::running_second() const {
  return running_second_;
}
inline void OprInfo::set_running_second(::google::protobuf::int32 value) {
  set_has_running_second();
  running_second_ = value;
}

// -------------------------------------------------------------------

// AgentInfo

// required string ip = 1;
inline bool AgentInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& AgentInfo::ip() const {
  return *ip_;
}
inline void AgentInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* AgentInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .dcmd_api.AgentState state = 2;
inline bool AgentInfo::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentInfo::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::AgentState AgentInfo::state() const {
  return static_cast< dcmd_api::AgentState >(state_);
}
inline void AgentInfo::set_state(dcmd_api::AgentState value) {
  GOOGLE_DCHECK(dcmd_api::AgentState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional string version = 3;
inline bool AgentInfo::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentInfo::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AgentInfo::version() const {
  return *version_;
}
inline void AgentInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AgentInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AgentInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AgentInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string connected_ip = 4;
inline bool AgentInfo::has_connected_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentInfo::set_has_connected_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentInfo::clear_has_connected_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentInfo::clear_connected_ip() {
  if (connected_ip_ != &::google::protobuf::internal::kEmptyString) {
    connected_ip_->clear();
  }
  clear_has_connected_ip();
}
inline const ::std::string& AgentInfo::connected_ip() const {
  return *connected_ip_;
}
inline void AgentInfo::set_connected_ip(const ::std::string& value) {
  set_has_connected_ip();
  if (connected_ip_ == &::google::protobuf::internal::kEmptyString) {
    connected_ip_ = new ::std::string;
  }
  connected_ip_->assign(value);
}
inline void AgentInfo::set_connected_ip(const char* value) {
  set_has_connected_ip();
  if (connected_ip_ == &::google::protobuf::internal::kEmptyString) {
    connected_ip_ = new ::std::string;
  }
  connected_ip_->assign(value);
}
inline void AgentInfo::set_connected_ip(const char* value, size_t size) {
  set_has_connected_ip();
  if (connected_ip_ == &::google::protobuf::internal::kEmptyString) {
    connected_ip_ = new ::std::string;
  }
  connected_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfo::mutable_connected_ip() {
  set_has_connected_ip();
  if (connected_ip_ == &::google::protobuf::internal::kEmptyString) {
    connected_ip_ = new ::std::string;
  }
  return connected_ip_;
}
inline ::std::string* AgentInfo::release_connected_ip() {
  clear_has_connected_ip();
  if (connected_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connected_ip_;
    connected_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string repored_ip = 5;
inline bool AgentInfo::has_repored_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AgentInfo::set_has_repored_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AgentInfo::clear_has_repored_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AgentInfo::clear_repored_ip() {
  if (repored_ip_ != &::google::protobuf::internal::kEmptyString) {
    repored_ip_->clear();
  }
  clear_has_repored_ip();
}
inline const ::std::string& AgentInfo::repored_ip() const {
  return *repored_ip_;
}
inline void AgentInfo::set_repored_ip(const ::std::string& value) {
  set_has_repored_ip();
  if (repored_ip_ == &::google::protobuf::internal::kEmptyString) {
    repored_ip_ = new ::std::string;
  }
  repored_ip_->assign(value);
}
inline void AgentInfo::set_repored_ip(const char* value) {
  set_has_repored_ip();
  if (repored_ip_ == &::google::protobuf::internal::kEmptyString) {
    repored_ip_ = new ::std::string;
  }
  repored_ip_->assign(value);
}
inline void AgentInfo::set_repored_ip(const char* value, size_t size) {
  set_has_repored_ip();
  if (repored_ip_ == &::google::protobuf::internal::kEmptyString) {
    repored_ip_ = new ::std::string;
  }
  repored_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentInfo::mutable_repored_ip() {
  set_has_repored_ip();
  if (repored_ip_ == &::google::protobuf::internal::kEmptyString) {
    repored_ip_ = new ::std::string;
  }
  return repored_ip_;
}
inline ::std::string* AgentInfo::release_repored_ip() {
  clear_has_repored_ip();
  if (repored_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = repored_ip_;
    repored_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentReport

// required string version = 1;
inline bool AgentReport::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentReport::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentReport::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentReport::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AgentReport::version() const {
  return *version_;
}
inline void AgentReport::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AgentReport::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AgentReport::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentReport::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AgentReport::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string agent_ips = 2;
inline int AgentReport::agent_ips_size() const {
  return agent_ips_.size();
}
inline void AgentReport::clear_agent_ips() {
  agent_ips_.Clear();
}
inline const ::std::string& AgentReport::agent_ips(int index) const {
  return agent_ips_.Get(index);
}
inline ::std::string* AgentReport::mutable_agent_ips(int index) {
  return agent_ips_.Mutable(index);
}
inline void AgentReport::set_agent_ips(int index, const ::std::string& value) {
  agent_ips_.Mutable(index)->assign(value);
}
inline void AgentReport::set_agent_ips(int index, const char* value) {
  agent_ips_.Mutable(index)->assign(value);
}
inline void AgentReport::set_agent_ips(int index, const char* value, size_t size) {
  agent_ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentReport::add_agent_ips() {
  return agent_ips_.Add();
}
inline void AgentReport::add_agent_ips(const ::std::string& value) {
  agent_ips_.Add()->assign(value);
}
inline void AgentReport::add_agent_ips(const char* value) {
  agent_ips_.Add()->assign(value);
}
inline void AgentReport::add_agent_ips(const char* value, size_t size) {
  agent_ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AgentReport::agent_ips() const {
  return agent_ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AgentReport::mutable_agent_ips() {
  return &agent_ips_;
}

// -------------------------------------------------------------------

// AgentReportReply

// required .dcmd_api.DcmdState state = 1;
inline bool AgentReportReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentReportReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentReportReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentReportReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState AgentReportReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void AgentReportReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional string err = 2;
inline bool AgentReportReply::has_err() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentReportReply::set_has_err() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentReportReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentReportReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& AgentReportReply::err() const {
  return *err_;
}
inline void AgentReportReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentReportReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentReportReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentReportReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* AgentReportReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 heatbeat = 3;
inline bool AgentReportReply::has_heatbeat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentReportReply::set_has_heatbeat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentReportReply::clear_has_heatbeat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentReportReply::clear_heatbeat() {
  heatbeat_ = 0;
  clear_has_heatbeat();
}
inline ::google::protobuf::int32 AgentReportReply::heatbeat() const {
  return heatbeat_;
}
inline void AgentReportReply::set_heatbeat(::google::protobuf::int32 value) {
  set_has_heatbeat();
  heatbeat_ = value;
}

// optional int32 package_size = 4;
inline bool AgentReportReply::has_package_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentReportReply::set_has_package_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentReportReply::clear_has_package_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentReportReply::clear_package_size() {
  package_size_ = 0;
  clear_has_package_size();
}
inline ::google::protobuf::int32 AgentReportReply::package_size() const {
  return package_size_;
}
inline void AgentReportReply::set_package_size(::google::protobuf::int32 value) {
  set_has_package_size();
  package_size_ = value;
}

// -------------------------------------------------------------------

// AgentMasterNoticeReply

// repeated string cmd = 1;
inline int AgentMasterNoticeReply::cmd_size() const {
  return cmd_.size();
}
inline void AgentMasterNoticeReply::clear_cmd() {
  cmd_.Clear();
}
inline const ::std::string& AgentMasterNoticeReply::cmd(int index) const {
  return cmd_.Get(index);
}
inline ::std::string* AgentMasterNoticeReply::mutable_cmd(int index) {
  return cmd_.Mutable(index);
}
inline void AgentMasterNoticeReply::set_cmd(int index, const ::std::string& value) {
  cmd_.Mutable(index)->assign(value);
}
inline void AgentMasterNoticeReply::set_cmd(int index, const char* value) {
  cmd_.Mutable(index)->assign(value);
}
inline void AgentMasterNoticeReply::set_cmd(int index, const char* value, size_t size) {
  cmd_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentMasterNoticeReply::add_cmd() {
  return cmd_.Add();
}
inline void AgentMasterNoticeReply::add_cmd(const ::std::string& value) {
  cmd_.Add()->assign(value);
}
inline void AgentMasterNoticeReply::add_cmd(const char* value) {
  cmd_.Add()->assign(value);
}
inline void AgentMasterNoticeReply::add_cmd(const char* value, size_t size) {
  cmd_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AgentMasterNoticeReply::cmd() const {
  return cmd_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AgentMasterNoticeReply::mutable_cmd() {
  return &cmd_;
}

// -------------------------------------------------------------------

// AgentTaskCmd

// required string cmd = 1;
inline bool AgentTaskCmd::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentTaskCmd::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentTaskCmd::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentTaskCmd::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& AgentTaskCmd::cmd() const {
  return *cmd_;
}
inline void AgentTaskCmd::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskCmd::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskCmd::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* AgentTaskCmd::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string task_type = 2;
inline bool AgentTaskCmd::has_task_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentTaskCmd::set_has_task_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentTaskCmd::clear_has_task_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentTaskCmd::clear_task_type() {
  if (task_type_ != &::google::protobuf::internal::kEmptyString) {
    task_type_->clear();
  }
  clear_has_task_type();
}
inline const ::std::string& AgentTaskCmd::task_type() const {
  return *task_type_;
}
inline void AgentTaskCmd::set_task_type(const ::std::string& value) {
  set_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    task_type_ = new ::std::string;
  }
  task_type_->assign(value);
}
inline void AgentTaskCmd::set_task_type(const char* value) {
  set_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    task_type_ = new ::std::string;
  }
  task_type_->assign(value);
}
inline void AgentTaskCmd::set_task_type(const char* value, size_t size) {
  set_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    task_type_ = new ::std::string;
  }
  task_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_task_type() {
  set_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    task_type_ = new ::std::string;
  }
  return task_type_;
}
inline ::std::string* AgentTaskCmd::release_task_type() {
  clear_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_type_;
    task_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string task_id = 3;
inline bool AgentTaskCmd::has_task_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentTaskCmd::set_has_task_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentTaskCmd::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentTaskCmd::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& AgentTaskCmd::task_id() const {
  return *task_id_;
}
inline void AgentTaskCmd::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void AgentTaskCmd::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void AgentTaskCmd::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* AgentTaskCmd::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string subtask_id = 4;
inline bool AgentTaskCmd::has_subtask_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentTaskCmd::set_has_subtask_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentTaskCmd::clear_has_subtask_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentTaskCmd::clear_subtask_id() {
  if (subtask_id_ != &::google::protobuf::internal::kEmptyString) {
    subtask_id_->clear();
  }
  clear_has_subtask_id();
}
inline const ::std::string& AgentTaskCmd::subtask_id() const {
  return *subtask_id_;
}
inline void AgentTaskCmd::set_subtask_id(const ::std::string& value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentTaskCmd::set_subtask_id(const char* value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentTaskCmd::set_subtask_id(const char* value, size_t size) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_subtask_id() {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  return subtask_id_;
}
inline ::std::string* AgentTaskCmd::release_subtask_id() {
  clear_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtask_id_;
    subtask_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ip = 5;
inline bool AgentTaskCmd::has_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AgentTaskCmd::set_has_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AgentTaskCmd::clear_has_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AgentTaskCmd::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& AgentTaskCmd::ip() const {
  return *ip_;
}
inline void AgentTaskCmd::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentTaskCmd::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentTaskCmd::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* AgentTaskCmd::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string app_name = 6;
inline bool AgentTaskCmd::has_app_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AgentTaskCmd::set_has_app_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AgentTaskCmd::clear_has_app_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AgentTaskCmd::clear_app_name() {
  if (app_name_ != &::google::protobuf::internal::kEmptyString) {
    app_name_->clear();
  }
  clear_has_app_name();
}
inline const ::std::string& AgentTaskCmd::app_name() const {
  return *app_name_;
}
inline void AgentTaskCmd::set_app_name(const ::std::string& value) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(value);
}
inline void AgentTaskCmd::set_app_name(const char* value) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(value);
}
inline void AgentTaskCmd::set_app_name(const char* value, size_t size) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_app_name() {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  return app_name_;
}
inline ::std::string* AgentTaskCmd::release_app_name() {
  clear_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_name_;
    app_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string app_pool = 7;
inline bool AgentTaskCmd::has_app_pool() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AgentTaskCmd::set_has_app_pool() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AgentTaskCmd::clear_has_app_pool() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AgentTaskCmd::clear_app_pool() {
  if (app_pool_ != &::google::protobuf::internal::kEmptyString) {
    app_pool_->clear();
  }
  clear_has_app_pool();
}
inline const ::std::string& AgentTaskCmd::app_pool() const {
  return *app_pool_;
}
inline void AgentTaskCmd::set_app_pool(const ::std::string& value) {
  set_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    app_pool_ = new ::std::string;
  }
  app_pool_->assign(value);
}
inline void AgentTaskCmd::set_app_pool(const char* value) {
  set_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    app_pool_ = new ::std::string;
  }
  app_pool_->assign(value);
}
inline void AgentTaskCmd::set_app_pool(const char* value, size_t size) {
  set_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    app_pool_ = new ::std::string;
  }
  app_pool_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_app_pool() {
  set_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    app_pool_ = new ::std::string;
  }
  return app_pool_;
}
inline ::std::string* AgentTaskCmd::release_app_pool() {
  clear_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_pool_;
    app_pool_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string app_ver = 8;
inline bool AgentTaskCmd::has_app_ver() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AgentTaskCmd::set_has_app_ver() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AgentTaskCmd::clear_has_app_ver() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AgentTaskCmd::clear_app_ver() {
  if (app_ver_ != &::google::protobuf::internal::kEmptyString) {
    app_ver_->clear();
  }
  clear_has_app_ver();
}
inline const ::std::string& AgentTaskCmd::app_ver() const {
  return *app_ver_;
}
inline void AgentTaskCmd::set_app_ver(const ::std::string& value) {
  set_has_app_ver();
  if (app_ver_ == &::google::protobuf::internal::kEmptyString) {
    app_ver_ = new ::std::string;
  }
  app_ver_->assign(value);
}
inline void AgentTaskCmd::set_app_ver(const char* value) {
  set_has_app_ver();
  if (app_ver_ == &::google::protobuf::internal::kEmptyString) {
    app_ver_ = new ::std::string;
  }
  app_ver_->assign(value);
}
inline void AgentTaskCmd::set_app_ver(const char* value, size_t size) {
  set_has_app_ver();
  if (app_ver_ == &::google::protobuf::internal::kEmptyString) {
    app_ver_ = new ::std::string;
  }
  app_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_app_ver() {
  set_has_app_ver();
  if (app_ver_ == &::google::protobuf::internal::kEmptyString) {
    app_ver_ = new ::std::string;
  }
  return app_ver_;
}
inline ::std::string* AgentTaskCmd::release_app_ver() {
  clear_has_app_ver();
  if (app_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_ver_;
    app_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string app_repo = 9;
inline bool AgentTaskCmd::has_app_repo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AgentTaskCmd::set_has_app_repo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AgentTaskCmd::clear_has_app_repo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AgentTaskCmd::clear_app_repo() {
  if (app_repo_ != &::google::protobuf::internal::kEmptyString) {
    app_repo_->clear();
  }
  clear_has_app_repo();
}
inline const ::std::string& AgentTaskCmd::app_repo() const {
  return *app_repo_;
}
inline void AgentTaskCmd::set_app_repo(const ::std::string& value) {
  set_has_app_repo();
  if (app_repo_ == &::google::protobuf::internal::kEmptyString) {
    app_repo_ = new ::std::string;
  }
  app_repo_->assign(value);
}
inline void AgentTaskCmd::set_app_repo(const char* value) {
  set_has_app_repo();
  if (app_repo_ == &::google::protobuf::internal::kEmptyString) {
    app_repo_ = new ::std::string;
  }
  app_repo_->assign(value);
}
inline void AgentTaskCmd::set_app_repo(const char* value, size_t size) {
  set_has_app_repo();
  if (app_repo_ == &::google::protobuf::internal::kEmptyString) {
    app_repo_ = new ::std::string;
  }
  app_repo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_app_repo() {
  set_has_app_repo();
  if (app_repo_ == &::google::protobuf::internal::kEmptyString) {
    app_repo_ = new ::std::string;
  }
  return app_repo_;
}
inline ::std::string* AgentTaskCmd::release_app_repo() {
  clear_has_app_repo();
  if (app_repo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_repo_;
    app_repo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string app_path = 10;
inline bool AgentTaskCmd::has_app_path() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AgentTaskCmd::set_has_app_path() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AgentTaskCmd::clear_has_app_path() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AgentTaskCmd::clear_app_path() {
  if (app_path_ != &::google::protobuf::internal::kEmptyString) {
    app_path_->clear();
  }
  clear_has_app_path();
}
inline const ::std::string& AgentTaskCmd::app_path() const {
  return *app_path_;
}
inline void AgentTaskCmd::set_app_path(const ::std::string& value) {
  set_has_app_path();
  if (app_path_ == &::google::protobuf::internal::kEmptyString) {
    app_path_ = new ::std::string;
  }
  app_path_->assign(value);
}
inline void AgentTaskCmd::set_app_path(const char* value) {
  set_has_app_path();
  if (app_path_ == &::google::protobuf::internal::kEmptyString) {
    app_path_ = new ::std::string;
  }
  app_path_->assign(value);
}
inline void AgentTaskCmd::set_app_path(const char* value, size_t size) {
  set_has_app_path();
  if (app_path_ == &::google::protobuf::internal::kEmptyString) {
    app_path_ = new ::std::string;
  }
  app_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_app_path() {
  set_has_app_path();
  if (app_path_ == &::google::protobuf::internal::kEmptyString) {
    app_path_ = new ::std::string;
  }
  return app_path_;
}
inline ::std::string* AgentTaskCmd::release_app_path() {
  clear_has_app_path();
  if (app_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_path_;
    app_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string app_user = 11;
inline bool AgentTaskCmd::has_app_user() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AgentTaskCmd::set_has_app_user() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AgentTaskCmd::clear_has_app_user() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AgentTaskCmd::clear_app_user() {
  if (app_user_ != &::google::protobuf::internal::kEmptyString) {
    app_user_->clear();
  }
  clear_has_app_user();
}
inline const ::std::string& AgentTaskCmd::app_user() const {
  return *app_user_;
}
inline void AgentTaskCmd::set_app_user(const ::std::string& value) {
  set_has_app_user();
  if (app_user_ == &::google::protobuf::internal::kEmptyString) {
    app_user_ = new ::std::string;
  }
  app_user_->assign(value);
}
inline void AgentTaskCmd::set_app_user(const char* value) {
  set_has_app_user();
  if (app_user_ == &::google::protobuf::internal::kEmptyString) {
    app_user_ = new ::std::string;
  }
  app_user_->assign(value);
}
inline void AgentTaskCmd::set_app_user(const char* value, size_t size) {
  set_has_app_user();
  if (app_user_ == &::google::protobuf::internal::kEmptyString) {
    app_user_ = new ::std::string;
  }
  app_user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_app_user() {
  set_has_app_user();
  if (app_user_ == &::google::protobuf::internal::kEmptyString) {
    app_user_ = new ::std::string;
  }
  return app_user_;
}
inline ::std::string* AgentTaskCmd::release_app_user() {
  clear_has_app_user();
  if (app_user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_user_;
    app_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string app_env_file = 12;
inline bool AgentTaskCmd::has_app_env_file() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AgentTaskCmd::set_has_app_env_file() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AgentTaskCmd::clear_has_app_env_file() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AgentTaskCmd::clear_app_env_file() {
  if (app_env_file_ != &::google::protobuf::internal::kEmptyString) {
    app_env_file_->clear();
  }
  clear_has_app_env_file();
}
inline const ::std::string& AgentTaskCmd::app_env_file() const {
  return *app_env_file_;
}
inline void AgentTaskCmd::set_app_env_file(const ::std::string& value) {
  set_has_app_env_file();
  if (app_env_file_ == &::google::protobuf::internal::kEmptyString) {
    app_env_file_ = new ::std::string;
  }
  app_env_file_->assign(value);
}
inline void AgentTaskCmd::set_app_env_file(const char* value) {
  set_has_app_env_file();
  if (app_env_file_ == &::google::protobuf::internal::kEmptyString) {
    app_env_file_ = new ::std::string;
  }
  app_env_file_->assign(value);
}
inline void AgentTaskCmd::set_app_env_file(const char* value, size_t size) {
  set_has_app_env_file();
  if (app_env_file_ == &::google::protobuf::internal::kEmptyString) {
    app_env_file_ = new ::std::string;
  }
  app_env_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_app_env_file() {
  set_has_app_env_file();
  if (app_env_file_ == &::google::protobuf::internal::kEmptyString) {
    app_env_file_ = new ::std::string;
  }
  return app_env_file_;
}
inline ::std::string* AgentTaskCmd::release_app_env_file() {
  clear_has_app_env_file();
  if (app_env_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_env_file_;
    app_env_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string app_env_ver = 13;
inline bool AgentTaskCmd::has_app_env_ver() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AgentTaskCmd::set_has_app_env_ver() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AgentTaskCmd::clear_has_app_env_ver() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AgentTaskCmd::clear_app_env_ver() {
  if (app_env_ver_ != &::google::protobuf::internal::kEmptyString) {
    app_env_ver_->clear();
  }
  clear_has_app_env_ver();
}
inline const ::std::string& AgentTaskCmd::app_env_ver() const {
  return *app_env_ver_;
}
inline void AgentTaskCmd::set_app_env_ver(const ::std::string& value) {
  set_has_app_env_ver();
  if (app_env_ver_ == &::google::protobuf::internal::kEmptyString) {
    app_env_ver_ = new ::std::string;
  }
  app_env_ver_->assign(value);
}
inline void AgentTaskCmd::set_app_env_ver(const char* value) {
  set_has_app_env_ver();
  if (app_env_ver_ == &::google::protobuf::internal::kEmptyString) {
    app_env_ver_ = new ::std::string;
  }
  app_env_ver_->assign(value);
}
inline void AgentTaskCmd::set_app_env_ver(const char* value, size_t size) {
  set_has_app_env_ver();
  if (app_env_ver_ == &::google::protobuf::internal::kEmptyString) {
    app_env_ver_ = new ::std::string;
  }
  app_env_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_app_env_ver() {
  set_has_app_env_ver();
  if (app_env_ver_ == &::google::protobuf::internal::kEmptyString) {
    app_env_ver_ = new ::std::string;
  }
  return app_env_ver_;
}
inline ::std::string* AgentTaskCmd::release_app_env_ver() {
  clear_has_app_env_ver();
  if (app_env_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_env_ver_;
    app_env_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool output_process = 14;
inline bool AgentTaskCmd::has_output_process() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AgentTaskCmd::set_has_output_process() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AgentTaskCmd::clear_has_output_process() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AgentTaskCmd::clear_output_process() {
  output_process_ = false;
  clear_has_output_process();
}
inline bool AgentTaskCmd::output_process() const {
  return output_process_;
}
inline void AgentTaskCmd::set_output_process(bool value) {
  set_has_output_process();
  output_process_ = value;
}

// optional bytes script = 15;
inline bool AgentTaskCmd::has_script() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AgentTaskCmd::set_has_script() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AgentTaskCmd::clear_has_script() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AgentTaskCmd::clear_script() {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& AgentTaskCmd::script() const {
  return *script_;
}
inline void AgentTaskCmd::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void AgentTaskCmd::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void AgentTaskCmd::set_script(const void* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  return script_;
}
inline ::std::string* AgentTaskCmd::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .dcmd_api.KeyValue task_arg = 16;
inline int AgentTaskCmd::task_arg_size() const {
  return task_arg_.size();
}
inline void AgentTaskCmd::clear_task_arg() {
  task_arg_.Clear();
}
inline const ::dcmd_api::KeyValue& AgentTaskCmd::task_arg(int index) const {
  return task_arg_.Get(index);
}
inline ::dcmd_api::KeyValue* AgentTaskCmd::mutable_task_arg(int index) {
  return task_arg_.Mutable(index);
}
inline ::dcmd_api::KeyValue* AgentTaskCmd::add_task_arg() {
  return task_arg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >&
AgentTaskCmd::task_arg() const {
  return task_arg_;
}
inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >*
AgentTaskCmd::mutable_task_arg() {
  return &task_arg_;
}

// -------------------------------------------------------------------

// AgentTaskCmdReply

// required string cmd = 1;
inline bool AgentTaskCmdReply::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentTaskCmdReply::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentTaskCmdReply::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentTaskCmdReply::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& AgentTaskCmdReply::cmd() const {
  return *cmd_;
}
inline void AgentTaskCmdReply::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskCmdReply::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskCmdReply::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmdReply::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* AgentTaskCmdReply::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentSubTaskProcess

// required string task_id = 1;
inline bool AgentSubTaskProcess::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentSubTaskProcess::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentSubTaskProcess::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentSubTaskProcess::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& AgentSubTaskProcess::task_id() const {
  return *task_id_;
}
inline void AgentSubTaskProcess::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void AgentSubTaskProcess::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void AgentSubTaskProcess::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentSubTaskProcess::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* AgentSubTaskProcess::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string subtask_id = 2;
inline bool AgentSubTaskProcess::has_subtask_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentSubTaskProcess::set_has_subtask_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentSubTaskProcess::clear_has_subtask_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentSubTaskProcess::clear_subtask_id() {
  if (subtask_id_ != &::google::protobuf::internal::kEmptyString) {
    subtask_id_->clear();
  }
  clear_has_subtask_id();
}
inline const ::std::string& AgentSubTaskProcess::subtask_id() const {
  return *subtask_id_;
}
inline void AgentSubTaskProcess::set_subtask_id(const ::std::string& value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentSubTaskProcess::set_subtask_id(const char* value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentSubTaskProcess::set_subtask_id(const char* value, size_t size) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentSubTaskProcess::mutable_subtask_id() {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  return subtask_id_;
}
inline ::std::string* AgentSubTaskProcess::release_subtask_id() {
  clear_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtask_id_;
    subtask_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string process = 3;
inline bool AgentSubTaskProcess::has_process() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentSubTaskProcess::set_has_process() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentSubTaskProcess::clear_has_process() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentSubTaskProcess::clear_process() {
  if (process_ != &::google::protobuf::internal::kEmptyString) {
    process_->clear();
  }
  clear_has_process();
}
inline const ::std::string& AgentSubTaskProcess::process() const {
  return *process_;
}
inline void AgentSubTaskProcess::set_process(const ::std::string& value) {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  process_->assign(value);
}
inline void AgentSubTaskProcess::set_process(const char* value) {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  process_->assign(value);
}
inline void AgentSubTaskProcess::set_process(const char* value, size_t size) {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  process_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentSubTaskProcess::mutable_process() {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  return process_;
}
inline ::std::string* AgentSubTaskProcess::release_process() {
  clear_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = process_;
    process_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentTaskResult

// required string cmd = 1;
inline bool AgentTaskResult::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentTaskResult::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentTaskResult::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentTaskResult::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& AgentTaskResult::cmd() const {
  return *cmd_;
}
inline void AgentTaskResult::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskResult::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskResult::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskResult::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* AgentTaskResult::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string task_id = 2;
inline bool AgentTaskResult::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentTaskResult::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentTaskResult::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentTaskResult::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& AgentTaskResult::task_id() const {
  return *task_id_;
}
inline void AgentTaskResult::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void AgentTaskResult::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void AgentTaskResult::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskResult::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* AgentTaskResult::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string subtask_id = 3;
inline bool AgentTaskResult::has_subtask_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentTaskResult::set_has_subtask_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentTaskResult::clear_has_subtask_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentTaskResult::clear_subtask_id() {
  if (subtask_id_ != &::google::protobuf::internal::kEmptyString) {
    subtask_id_->clear();
  }
  clear_has_subtask_id();
}
inline const ::std::string& AgentTaskResult::subtask_id() const {
  return *subtask_id_;
}
inline void AgentTaskResult::set_subtask_id(const ::std::string& value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentTaskResult::set_subtask_id(const char* value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentTaskResult::set_subtask_id(const char* value, size_t size) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskResult::mutable_subtask_id() {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  return subtask_id_;
}
inline ::std::string* AgentTaskResult::release_subtask_id() {
  clear_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtask_id_;
    subtask_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool success = 4;
inline bool AgentTaskResult::has_success() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentTaskResult::set_has_success() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentTaskResult::clear_has_success() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentTaskResult::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool AgentTaskResult::success() const {
  return success_;
}
inline void AgentTaskResult::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional string err = 5;
inline bool AgentTaskResult::has_err() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AgentTaskResult::set_has_err() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AgentTaskResult::clear_has_err() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AgentTaskResult::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& AgentTaskResult::err() const {
  return *err_;
}
inline void AgentTaskResult::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentTaskResult::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentTaskResult::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskResult::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* AgentTaskResult::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string process = 6;
inline bool AgentTaskResult::has_process() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AgentTaskResult::set_has_process() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AgentTaskResult::clear_has_process() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AgentTaskResult::clear_process() {
  if (process_ != &::google::protobuf::internal::kEmptyString) {
    process_->clear();
  }
  clear_has_process();
}
inline const ::std::string& AgentTaskResult::process() const {
  return *process_;
}
inline void AgentTaskResult::set_process(const ::std::string& value) {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  process_->assign(value);
}
inline void AgentTaskResult::set_process(const char* value) {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  process_->assign(value);
}
inline void AgentTaskResult::set_process(const char* value, size_t size) {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  process_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskResult::mutable_process() {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  return process_;
}
inline ::std::string* AgentTaskResult::release_process() {
  clear_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = process_;
    process_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentTaskResultReply

// required string cmd = 1;
inline bool AgentTaskResultReply::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentTaskResultReply::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentTaskResultReply::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentTaskResultReply::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& AgentTaskResultReply::cmd() const {
  return *cmd_;
}
inline void AgentTaskResultReply::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskResultReply::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskResultReply::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskResultReply::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* AgentTaskResultReply::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentOprCmd

// required string opr_id = 1;
inline bool AgentOprCmd::has_opr_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentOprCmd::set_has_opr_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentOprCmd::clear_has_opr_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentOprCmd::clear_opr_id() {
  if (opr_id_ != &::google::protobuf::internal::kEmptyString) {
    opr_id_->clear();
  }
  clear_has_opr_id();
}
inline const ::std::string& AgentOprCmd::opr_id() const {
  return *opr_id_;
}
inline void AgentOprCmd::set_opr_id(const ::std::string& value) {
  set_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    opr_id_ = new ::std::string;
  }
  opr_id_->assign(value);
}
inline void AgentOprCmd::set_opr_id(const char* value) {
  set_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    opr_id_ = new ::std::string;
  }
  opr_id_->assign(value);
}
inline void AgentOprCmd::set_opr_id(const char* value, size_t size) {
  set_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    opr_id_ = new ::std::string;
  }
  opr_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentOprCmd::mutable_opr_id() {
  set_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    opr_id_ = new ::std::string;
  }
  return opr_id_;
}
inline ::std::string* AgentOprCmd::release_opr_id() {
  clear_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opr_id_;
    opr_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool AgentOprCmd::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentOprCmd::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentOprCmd::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentOprCmd::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AgentOprCmd::name() const {
  return *name_;
}
inline void AgentOprCmd::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AgentOprCmd::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AgentOprCmd::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentOprCmd::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AgentOprCmd::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string run_user = 3;
inline bool AgentOprCmd::has_run_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentOprCmd::set_has_run_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentOprCmd::clear_has_run_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentOprCmd::clear_run_user() {
  if (run_user_ != &::google::protobuf::internal::kEmptyString) {
    run_user_->clear();
  }
  clear_has_run_user();
}
inline const ::std::string& AgentOprCmd::run_user() const {
  return *run_user_;
}
inline void AgentOprCmd::set_run_user(const ::std::string& value) {
  set_has_run_user();
  if (run_user_ == &::google::protobuf::internal::kEmptyString) {
    run_user_ = new ::std::string;
  }
  run_user_->assign(value);
}
inline void AgentOprCmd::set_run_user(const char* value) {
  set_has_run_user();
  if (run_user_ == &::google::protobuf::internal::kEmptyString) {
    run_user_ = new ::std::string;
  }
  run_user_->assign(value);
}
inline void AgentOprCmd::set_run_user(const char* value, size_t size) {
  set_has_run_user();
  if (run_user_ == &::google::protobuf::internal::kEmptyString) {
    run_user_ = new ::std::string;
  }
  run_user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentOprCmd::mutable_run_user() {
  set_has_run_user();
  if (run_user_ == &::google::protobuf::internal::kEmptyString) {
    run_user_ = new ::std::string;
  }
  return run_user_;
}
inline ::std::string* AgentOprCmd::release_run_user() {
  clear_has_run_user();
  if (run_user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = run_user_;
    run_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 timeout = 4;
inline bool AgentOprCmd::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentOprCmd::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentOprCmd::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentOprCmd::clear_timeout() {
  timeout_ = 0;
  clear_has_timeout();
}
inline ::google::protobuf::int32 AgentOprCmd::timeout() const {
  return timeout_;
}
inline void AgentOprCmd::set_timeout(::google::protobuf::int32 value) {
  set_has_timeout();
  timeout_ = value;
}

// required bytes script = 5;
inline bool AgentOprCmd::has_script() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AgentOprCmd::set_has_script() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AgentOprCmd::clear_has_script() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AgentOprCmd::clear_script() {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& AgentOprCmd::script() const {
  return *script_;
}
inline void AgentOprCmd::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void AgentOprCmd::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void AgentOprCmd::set_script(const void* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentOprCmd::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  return script_;
}
inline ::std::string* AgentOprCmd::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .dcmd_api.KeyValue args = 6;
inline int AgentOprCmd::args_size() const {
  return args_.size();
}
inline void AgentOprCmd::clear_args() {
  args_.Clear();
}
inline const ::dcmd_api::KeyValue& AgentOprCmd::args(int index) const {
  return args_.Get(index);
}
inline ::dcmd_api::KeyValue* AgentOprCmd::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::dcmd_api::KeyValue* AgentOprCmd::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >&
AgentOprCmd::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >*
AgentOprCmd::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// AgentOprCmdReply

// required .dcmd_api.DcmdState state = 1;
inline bool AgentOprCmdReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentOprCmdReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentOprCmdReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentOprCmdReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState AgentOprCmdReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void AgentOprCmdReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// required bytes result = 2;
inline bool AgentOprCmdReply::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentOprCmdReply::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentOprCmdReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentOprCmdReply::clear_result() {
  if (result_ != &::google::protobuf::internal::kEmptyString) {
    result_->clear();
  }
  clear_has_result();
}
inline const ::std::string& AgentOprCmdReply::result() const {
  return *result_;
}
inline void AgentOprCmdReply::set_result(const ::std::string& value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void AgentOprCmdReply::set_result(const char* value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void AgentOprCmdReply::set_result(const void* value, size_t size) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentOprCmdReply::mutable_result() {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  return result_;
}
inline ::std::string* AgentOprCmdReply::release_result() {
  clear_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_;
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string err = 3;
inline bool AgentOprCmdReply::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentOprCmdReply::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentOprCmdReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentOprCmdReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& AgentOprCmdReply::err() const {
  return *err_;
}
inline void AgentOprCmdReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentOprCmdReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentOprCmdReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentOprCmdReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* AgentOprCmdReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ip = 4;
inline bool AgentOprCmdReply::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentOprCmdReply::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentOprCmdReply::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentOprCmdReply::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& AgentOprCmdReply::ip() const {
  return *ip_;
}
inline void AgentOprCmdReply::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentOprCmdReply::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentOprCmdReply::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentOprCmdReply::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* AgentOprCmdReply::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentTaskOutput

// required string subtask_id = 1;
inline bool AgentTaskOutput::has_subtask_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentTaskOutput::set_has_subtask_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentTaskOutput::clear_has_subtask_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentTaskOutput::clear_subtask_id() {
  if (subtask_id_ != &::google::protobuf::internal::kEmptyString) {
    subtask_id_->clear();
  }
  clear_has_subtask_id();
}
inline const ::std::string& AgentTaskOutput::subtask_id() const {
  return *subtask_id_;
}
inline void AgentTaskOutput::set_subtask_id(const ::std::string& value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentTaskOutput::set_subtask_id(const char* value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentTaskOutput::set_subtask_id(const char* value, size_t size) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskOutput::mutable_subtask_id() {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  return subtask_id_;
}
inline ::std::string* AgentTaskOutput::release_subtask_id() {
  clear_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtask_id_;
    subtask_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 offset = 2;
inline bool AgentTaskOutput::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentTaskOutput::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentTaskOutput::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentTaskOutput::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 AgentTaskOutput::offset() const {
  return offset_;
}
inline void AgentTaskOutput::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// optional string ip = 3;
inline bool AgentTaskOutput::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentTaskOutput::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentTaskOutput::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentTaskOutput::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& AgentTaskOutput::ip() const {
  return *ip_;
}
inline void AgentTaskOutput::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentTaskOutput::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentTaskOutput::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskOutput::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* AgentTaskOutput::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentTaskOutputReply

// required .dcmd_api.DcmdState state = 1;
inline bool AgentTaskOutputReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentTaskOutputReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentTaskOutputReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentTaskOutputReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState AgentTaskOutputReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void AgentTaskOutputReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// required bytes result = 2;
inline bool AgentTaskOutputReply::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentTaskOutputReply::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentTaskOutputReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentTaskOutputReply::clear_result() {
  if (result_ != &::google::protobuf::internal::kEmptyString) {
    result_->clear();
  }
  clear_has_result();
}
inline const ::std::string& AgentTaskOutputReply::result() const {
  return *result_;
}
inline void AgentTaskOutputReply::set_result(const ::std::string& value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void AgentTaskOutputReply::set_result(const char* value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void AgentTaskOutputReply::set_result(const void* value, size_t size) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskOutputReply::mutable_result() {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  return result_;
}
inline ::std::string* AgentTaskOutputReply::release_result() {
  clear_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_;
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 offset = 3;
inline bool AgentTaskOutputReply::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentTaskOutputReply::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentTaskOutputReply::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentTaskOutputReply::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 AgentTaskOutputReply::offset() const {
  return offset_;
}
inline void AgentTaskOutputReply::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// optional string err = 4;
inline bool AgentTaskOutputReply::has_err() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentTaskOutputReply::set_has_err() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentTaskOutputReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentTaskOutputReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& AgentTaskOutputReply::err() const {
  return *err_;
}
inline void AgentTaskOutputReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentTaskOutputReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentTaskOutputReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskOutputReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* AgentTaskOutputReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentRunningTask

// optional string ip = 1;
inline bool AgentRunningTask::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentRunningTask::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentRunningTask::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentRunningTask::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& AgentRunningTask::ip() const {
  return *ip_;
}
inline void AgentRunningTask::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentRunningTask::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentRunningTask::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentRunningTask::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* AgentRunningTask::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string app_name = 2;
inline bool AgentRunningTask::has_app_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentRunningTask::set_has_app_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentRunningTask::clear_has_app_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentRunningTask::clear_app_name() {
  if (app_name_ != &::google::protobuf::internal::kEmptyString) {
    app_name_->clear();
  }
  clear_has_app_name();
}
inline const ::std::string& AgentRunningTask::app_name() const {
  return *app_name_;
}
inline void AgentRunningTask::set_app_name(const ::std::string& value) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(value);
}
inline void AgentRunningTask::set_app_name(const char* value) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(value);
}
inline void AgentRunningTask::set_app_name(const char* value, size_t size) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentRunningTask::mutable_app_name() {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  return app_name_;
}
inline ::std::string* AgentRunningTask::release_app_name() {
  clear_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_name_;
    app_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentRunningTaskReply

// required .dcmd_api.DcmdState state = 1;
inline bool AgentRunningTaskReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentRunningTaskReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentRunningTaskReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentRunningTaskReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState AgentRunningTaskReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void AgentRunningTaskReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// repeated .dcmd_api.SubTaskInfo result = 2;
inline int AgentRunningTaskReply::result_size() const {
  return result_.size();
}
inline void AgentRunningTaskReply::clear_result() {
  result_.Clear();
}
inline const ::dcmd_api::SubTaskInfo& AgentRunningTaskReply::result(int index) const {
  return result_.Get(index);
}
inline ::dcmd_api::SubTaskInfo* AgentRunningTaskReply::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::dcmd_api::SubTaskInfo* AgentRunningTaskReply::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo >&
AgentRunningTaskReply::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo >*
AgentRunningTaskReply::mutable_result() {
  return &result_;
}

// optional string err = 3;
inline bool AgentRunningTaskReply::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentRunningTaskReply::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentRunningTaskReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentRunningTaskReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& AgentRunningTaskReply::err() const {
  return *err_;
}
inline void AgentRunningTaskReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentRunningTaskReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentRunningTaskReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentRunningTaskReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* AgentRunningTaskReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentRunningOpr

// optional string ip = 1;
inline bool AgentRunningOpr::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentRunningOpr::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentRunningOpr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentRunningOpr::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& AgentRunningOpr::ip() const {
  return *ip_;
}
inline void AgentRunningOpr::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentRunningOpr::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentRunningOpr::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentRunningOpr::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* AgentRunningOpr::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentRunningOprReply

// required .dcmd_api.DcmdState state = 1;
inline bool AgentRunningOprReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentRunningOprReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentRunningOprReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentRunningOprReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState AgentRunningOprReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void AgentRunningOprReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// repeated .dcmd_api.OprInfo result = 2;
inline int AgentRunningOprReply::result_size() const {
  return result_.size();
}
inline void AgentRunningOprReply::clear_result() {
  result_.Clear();
}
inline const ::dcmd_api::OprInfo& AgentRunningOprReply::result(int index) const {
  return result_.Get(index);
}
inline ::dcmd_api::OprInfo* AgentRunningOprReply::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::dcmd_api::OprInfo* AgentRunningOprReply::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo >&
AgentRunningOprReply::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo >*
AgentRunningOprReply::mutable_result() {
  return &result_;
}

// optional string err = 3;
inline bool AgentRunningOprReply::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentRunningOprReply::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentRunningOprReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentRunningOprReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& AgentRunningOprReply::err() const {
  return *err_;
}
inline void AgentRunningOprReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentRunningOprReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentRunningOprReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentRunningOprReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* AgentRunningOprReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// InvalidMsg

// required int32 msg_type = 1;
inline bool InvalidMsg::has_msg_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvalidMsg::set_has_msg_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvalidMsg::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvalidMsg::clear_msg_type() {
  msg_type_ = 0;
  clear_has_msg_type();
}
inline ::google::protobuf::int32 InvalidMsg::msg_type() const {
  return msg_type_;
}
inline void InvalidMsg::set_msg_type(::google::protobuf::int32 value) {
  set_has_msg_type();
  msg_type_ = value;
}

// -------------------------------------------------------------------

// UiTaskOutput

// required string subtask_id = 1;
inline bool UiTaskOutput::has_subtask_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiTaskOutput::set_has_subtask_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiTaskOutput::clear_has_subtask_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiTaskOutput::clear_subtask_id() {
  if (subtask_id_ != &::google::protobuf::internal::kEmptyString) {
    subtask_id_->clear();
  }
  clear_has_subtask_id();
}
inline const ::std::string& UiTaskOutput::subtask_id() const {
  return *subtask_id_;
}
inline void UiTaskOutput::set_subtask_id(const ::std::string& value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void UiTaskOutput::set_subtask_id(const char* value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void UiTaskOutput::set_subtask_id(const char* value, size_t size) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskOutput::mutable_subtask_id() {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  return subtask_id_;
}
inline ::std::string* UiTaskOutput::release_subtask_id() {
  clear_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtask_id_;
    subtask_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ip = 2;
inline bool UiTaskOutput::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiTaskOutput::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiTaskOutput::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiTaskOutput::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& UiTaskOutput::ip() const {
  return *ip_;
}
inline void UiTaskOutput::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UiTaskOutput::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UiTaskOutput::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskOutput::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* UiTaskOutput::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 offset = 3;
inline bool UiTaskOutput::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiTaskOutput::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiTaskOutput::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiTaskOutput::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 UiTaskOutput::offset() const {
  return offset_;
}
inline void UiTaskOutput::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// required string user = 4;
inline bool UiTaskOutput::has_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UiTaskOutput::set_has_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UiTaskOutput::clear_has_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UiTaskOutput::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& UiTaskOutput::user() const {
  return *user_;
}
inline void UiTaskOutput::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiTaskOutput::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiTaskOutput::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskOutput::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* UiTaskOutput::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string passwd = 5;
inline bool UiTaskOutput::has_passwd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UiTaskOutput::set_has_passwd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UiTaskOutput::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UiTaskOutput::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& UiTaskOutput::passwd() const {
  return *passwd_;
}
inline void UiTaskOutput::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiTaskOutput::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiTaskOutput::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskOutput::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* UiTaskOutput::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiTaskOutputReply

// required .dcmd_api.DcmdState state = 1;
inline bool UiTaskOutputReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiTaskOutputReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiTaskOutputReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiTaskOutputReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState UiTaskOutputReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void UiTaskOutputReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// required bytes result = 2;
inline bool UiTaskOutputReply::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiTaskOutputReply::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiTaskOutputReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiTaskOutputReply::clear_result() {
  if (result_ != &::google::protobuf::internal::kEmptyString) {
    result_->clear();
  }
  clear_has_result();
}
inline const ::std::string& UiTaskOutputReply::result() const {
  return *result_;
}
inline void UiTaskOutputReply::set_result(const ::std::string& value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void UiTaskOutputReply::set_result(const char* value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void UiTaskOutputReply::set_result(const void* value, size_t size) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskOutputReply::mutable_result() {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  return result_;
}
inline ::std::string* UiTaskOutputReply::release_result() {
  clear_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_;
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 offset = 3;
inline bool UiTaskOutputReply::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiTaskOutputReply::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiTaskOutputReply::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiTaskOutputReply::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 UiTaskOutputReply::offset() const {
  return offset_;
}
inline void UiTaskOutputReply::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// optional string err = 4;
inline bool UiTaskOutputReply::has_err() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UiTaskOutputReply::set_has_err() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UiTaskOutputReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UiTaskOutputReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& UiTaskOutputReply::err() const {
  return *err_;
}
inline void UiTaskOutputReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiTaskOutputReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiTaskOutputReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskOutputReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* UiTaskOutputReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiAgentRunningTask

// optional string ip = 1;
inline bool UiAgentRunningTask::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiAgentRunningTask::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiAgentRunningTask::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiAgentRunningTask::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& UiAgentRunningTask::ip() const {
  return *ip_;
}
inline void UiAgentRunningTask::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UiAgentRunningTask::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UiAgentRunningTask::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentRunningTask::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* UiAgentRunningTask::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string app_name = 2;
inline bool UiAgentRunningTask::has_app_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiAgentRunningTask::set_has_app_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiAgentRunningTask::clear_has_app_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiAgentRunningTask::clear_app_name() {
  if (app_name_ != &::google::protobuf::internal::kEmptyString) {
    app_name_->clear();
  }
  clear_has_app_name();
}
inline const ::std::string& UiAgentRunningTask::app_name() const {
  return *app_name_;
}
inline void UiAgentRunningTask::set_app_name(const ::std::string& value) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(value);
}
inline void UiAgentRunningTask::set_app_name(const char* value) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(value);
}
inline void UiAgentRunningTask::set_app_name(const char* value, size_t size) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentRunningTask::mutable_app_name() {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    app_name_ = new ::std::string;
  }
  return app_name_;
}
inline ::std::string* UiAgentRunningTask::release_app_name() {
  clear_has_app_name();
  if (app_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_name_;
    app_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string user = 3;
inline bool UiAgentRunningTask::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiAgentRunningTask::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiAgentRunningTask::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiAgentRunningTask::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& UiAgentRunningTask::user() const {
  return *user_;
}
inline void UiAgentRunningTask::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiAgentRunningTask::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiAgentRunningTask::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentRunningTask::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* UiAgentRunningTask::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string passwd = 4;
inline bool UiAgentRunningTask::has_passwd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UiAgentRunningTask::set_has_passwd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UiAgentRunningTask::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UiAgentRunningTask::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& UiAgentRunningTask::passwd() const {
  return *passwd_;
}
inline void UiAgentRunningTask::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiAgentRunningTask::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiAgentRunningTask::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentRunningTask::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* UiAgentRunningTask::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiAgentRunningTaskReply

// required .dcmd_api.DcmdState state = 1;
inline bool UiAgentRunningTaskReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiAgentRunningTaskReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiAgentRunningTaskReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiAgentRunningTaskReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState UiAgentRunningTaskReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void UiAgentRunningTaskReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// repeated .dcmd_api.SubTaskInfo result = 2;
inline int UiAgentRunningTaskReply::result_size() const {
  return result_.size();
}
inline void UiAgentRunningTaskReply::clear_result() {
  result_.Clear();
}
inline const ::dcmd_api::SubTaskInfo& UiAgentRunningTaskReply::result(int index) const {
  return result_.Get(index);
}
inline ::dcmd_api::SubTaskInfo* UiAgentRunningTaskReply::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::dcmd_api::SubTaskInfo* UiAgentRunningTaskReply::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo >&
UiAgentRunningTaskReply::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo >*
UiAgentRunningTaskReply::mutable_result() {
  return &result_;
}

// optional string err = 3;
inline bool UiAgentRunningTaskReply::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiAgentRunningTaskReply::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiAgentRunningTaskReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiAgentRunningTaskReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& UiAgentRunningTaskReply::err() const {
  return *err_;
}
inline void UiAgentRunningTaskReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiAgentRunningTaskReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiAgentRunningTaskReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentRunningTaskReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* UiAgentRunningTaskReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiAgentRunningOpr

// optional string ip = 1;
inline bool UiAgentRunningOpr::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiAgentRunningOpr::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiAgentRunningOpr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiAgentRunningOpr::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& UiAgentRunningOpr::ip() const {
  return *ip_;
}
inline void UiAgentRunningOpr::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UiAgentRunningOpr::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UiAgentRunningOpr::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentRunningOpr::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* UiAgentRunningOpr::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string user = 2;
inline bool UiAgentRunningOpr::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiAgentRunningOpr::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiAgentRunningOpr::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiAgentRunningOpr::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& UiAgentRunningOpr::user() const {
  return *user_;
}
inline void UiAgentRunningOpr::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiAgentRunningOpr::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiAgentRunningOpr::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentRunningOpr::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* UiAgentRunningOpr::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string passwd = 3;
inline bool UiAgentRunningOpr::has_passwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiAgentRunningOpr::set_has_passwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiAgentRunningOpr::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiAgentRunningOpr::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& UiAgentRunningOpr::passwd() const {
  return *passwd_;
}
inline void UiAgentRunningOpr::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiAgentRunningOpr::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiAgentRunningOpr::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentRunningOpr::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* UiAgentRunningOpr::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiAgentRunningOprReply

// required .dcmd_api.DcmdState state = 1;
inline bool UiAgentRunningOprReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiAgentRunningOprReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiAgentRunningOprReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiAgentRunningOprReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState UiAgentRunningOprReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void UiAgentRunningOprReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// repeated .dcmd_api.OprInfo result = 2;
inline int UiAgentRunningOprReply::result_size() const {
  return result_.size();
}
inline void UiAgentRunningOprReply::clear_result() {
  result_.Clear();
}
inline const ::dcmd_api::OprInfo& UiAgentRunningOprReply::result(int index) const {
  return result_.Get(index);
}
inline ::dcmd_api::OprInfo* UiAgentRunningOprReply::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::dcmd_api::OprInfo* UiAgentRunningOprReply::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo >&
UiAgentRunningOprReply::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo >*
UiAgentRunningOprReply::mutable_result() {
  return &result_;
}

// optional string err = 3;
inline bool UiAgentRunningOprReply::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiAgentRunningOprReply::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiAgentRunningOprReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiAgentRunningOprReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& UiAgentRunningOprReply::err() const {
  return *err_;
}
inline void UiAgentRunningOprReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiAgentRunningOprReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiAgentRunningOprReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentRunningOprReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* UiAgentRunningOprReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiExecOprCmd

// optional string opr_id = 1;
inline bool UiExecOprCmd::has_opr_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiExecOprCmd::set_has_opr_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiExecOprCmd::clear_has_opr_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiExecOprCmd::clear_opr_id() {
  if (opr_id_ != &::google::protobuf::internal::kEmptyString) {
    opr_id_->clear();
  }
  clear_has_opr_id();
}
inline const ::std::string& UiExecOprCmd::opr_id() const {
  return *opr_id_;
}
inline void UiExecOprCmd::set_opr_id(const ::std::string& value) {
  set_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    opr_id_ = new ::std::string;
  }
  opr_id_->assign(value);
}
inline void UiExecOprCmd::set_opr_id(const char* value) {
  set_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    opr_id_ = new ::std::string;
  }
  opr_id_->assign(value);
}
inline void UiExecOprCmd::set_opr_id(const char* value, size_t size) {
  set_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    opr_id_ = new ::std::string;
  }
  opr_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiExecOprCmd::mutable_opr_id() {
  set_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    opr_id_ = new ::std::string;
  }
  return opr_id_;
}
inline ::std::string* UiExecOprCmd::release_opr_id() {
  clear_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opr_id_;
    opr_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string user = 2;
inline bool UiExecOprCmd::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiExecOprCmd::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiExecOprCmd::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiExecOprCmd::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& UiExecOprCmd::user() const {
  return *user_;
}
inline void UiExecOprCmd::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiExecOprCmd::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiExecOprCmd::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiExecOprCmd::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* UiExecOprCmd::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string passwd = 3;
inline bool UiExecOprCmd::has_passwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiExecOprCmd::set_has_passwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiExecOprCmd::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiExecOprCmd::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& UiExecOprCmd::passwd() const {
  return *passwd_;
}
inline void UiExecOprCmd::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiExecOprCmd::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiExecOprCmd::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiExecOprCmd::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* UiExecOprCmd::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiExecOprCmdReply

// required .dcmd_api.DcmdState state = 1;
inline bool UiExecOprCmdReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiExecOprCmdReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiExecOprCmdReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiExecOprCmdReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState UiExecOprCmdReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void UiExecOprCmdReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// repeated .dcmd_api.AgentOprCmdReply result = 2;
inline int UiExecOprCmdReply::result_size() const {
  return result_.size();
}
inline void UiExecOprCmdReply::clear_result() {
  result_.Clear();
}
inline const ::dcmd_api::AgentOprCmdReply& UiExecOprCmdReply::result(int index) const {
  return result_.Get(index);
}
inline ::dcmd_api::AgentOprCmdReply* UiExecOprCmdReply::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::dcmd_api::AgentOprCmdReply* UiExecOprCmdReply::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::AgentOprCmdReply >&
UiExecOprCmdReply::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::AgentOprCmdReply >*
UiExecOprCmdReply::mutable_result() {
  return &result_;
}

// optional string err = 3;
inline bool UiExecOprCmdReply::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiExecOprCmdReply::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiExecOprCmdReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiExecOprCmdReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& UiExecOprCmdReply::err() const {
  return *err_;
}
inline void UiExecOprCmdReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiExecOprCmdReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiExecOprCmdReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiExecOprCmdReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* UiExecOprCmdReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiAgentInfo

// repeated string ips = 1;
inline int UiAgentInfo::ips_size() const {
  return ips_.size();
}
inline void UiAgentInfo::clear_ips() {
  ips_.Clear();
}
inline const ::std::string& UiAgentInfo::ips(int index) const {
  return ips_.Get(index);
}
inline ::std::string* UiAgentInfo::mutable_ips(int index) {
  return ips_.Mutable(index);
}
inline void UiAgentInfo::set_ips(int index, const ::std::string& value) {
  ips_.Mutable(index)->assign(value);
}
inline void UiAgentInfo::set_ips(int index, const char* value) {
  ips_.Mutable(index)->assign(value);
}
inline void UiAgentInfo::set_ips(int index, const char* value, size_t size) {
  ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentInfo::add_ips() {
  return ips_.Add();
}
inline void UiAgentInfo::add_ips(const ::std::string& value) {
  ips_.Add()->assign(value);
}
inline void UiAgentInfo::add_ips(const char* value) {
  ips_.Add()->assign(value);
}
inline void UiAgentInfo::add_ips(const char* value, size_t size) {
  ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UiAgentInfo::ips() const {
  return ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UiAgentInfo::mutable_ips() {
  return &ips_;
}

// required bool version = 2;
inline bool UiAgentInfo::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiAgentInfo::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiAgentInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiAgentInfo::clear_version() {
  version_ = false;
  clear_has_version();
}
inline bool UiAgentInfo::version() const {
  return version_;
}
inline void UiAgentInfo::set_version(bool value) {
  set_has_version();
  version_ = value;
}

// required string user = 3;
inline bool UiAgentInfo::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiAgentInfo::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiAgentInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiAgentInfo::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& UiAgentInfo::user() const {
  return *user_;
}
inline void UiAgentInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiAgentInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiAgentInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentInfo::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* UiAgentInfo::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string passwd = 4;
inline bool UiAgentInfo::has_passwd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UiAgentInfo::set_has_passwd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UiAgentInfo::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UiAgentInfo::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& UiAgentInfo::passwd() const {
  return *passwd_;
}
inline void UiAgentInfo::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiAgentInfo::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiAgentInfo::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentInfo::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* UiAgentInfo::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiAgentInfoReply

// required .dcmd_api.DcmdState state = 1;
inline bool UiAgentInfoReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiAgentInfoReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiAgentInfoReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiAgentInfoReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState UiAgentInfoReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void UiAgentInfoReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// repeated .dcmd_api.AgentInfo agentinfo = 2;
inline int UiAgentInfoReply::agentinfo_size() const {
  return agentinfo_.size();
}
inline void UiAgentInfoReply::clear_agentinfo() {
  agentinfo_.Clear();
}
inline const ::dcmd_api::AgentInfo& UiAgentInfoReply::agentinfo(int index) const {
  return agentinfo_.Get(index);
}
inline ::dcmd_api::AgentInfo* UiAgentInfoReply::mutable_agentinfo(int index) {
  return agentinfo_.Mutable(index);
}
inline ::dcmd_api::AgentInfo* UiAgentInfoReply::add_agentinfo() {
  return agentinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::AgentInfo >&
UiAgentInfoReply::agentinfo() const {
  return agentinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::AgentInfo >*
UiAgentInfoReply::mutable_agentinfo() {
  return &agentinfo_;
}

// optional string err = 3;
inline bool UiAgentInfoReply::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiAgentInfoReply::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiAgentInfoReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiAgentInfoReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& UiAgentInfoReply::err() const {
  return *err_;
}
inline void UiAgentInfoReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiAgentInfoReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiAgentInfoReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentInfoReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* UiAgentInfoReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiInvalidAgentInfo

// required string user = 1;
inline bool UiInvalidAgentInfo::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiInvalidAgentInfo::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiInvalidAgentInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiInvalidAgentInfo::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& UiInvalidAgentInfo::user() const {
  return *user_;
}
inline void UiInvalidAgentInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiInvalidAgentInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiInvalidAgentInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiInvalidAgentInfo::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* UiInvalidAgentInfo::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string passwd = 2;
inline bool UiInvalidAgentInfo::has_passwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiInvalidAgentInfo::set_has_passwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiInvalidAgentInfo::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiInvalidAgentInfo::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& UiInvalidAgentInfo::passwd() const {
  return *passwd_;
}
inline void UiInvalidAgentInfo::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiInvalidAgentInfo::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiInvalidAgentInfo::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiInvalidAgentInfo::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* UiInvalidAgentInfo::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiInvalidAgentInfoReply

// required .dcmd_api.DcmdState state = 1;
inline bool UiInvalidAgentInfoReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiInvalidAgentInfoReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiInvalidAgentInfoReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiInvalidAgentInfoReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState UiInvalidAgentInfoReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void UiInvalidAgentInfoReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// required .dcmd_api.AgentInfo agentinfo = 2;
inline bool UiInvalidAgentInfoReply::has_agentinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiInvalidAgentInfoReply::set_has_agentinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiInvalidAgentInfoReply::clear_has_agentinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiInvalidAgentInfoReply::clear_agentinfo() {
  if (agentinfo_ != NULL) agentinfo_->::dcmd_api::AgentInfo::Clear();
  clear_has_agentinfo();
}
inline const ::dcmd_api::AgentInfo& UiInvalidAgentInfoReply::agentinfo() const {
  return agentinfo_ != NULL ? *agentinfo_ : *default_instance_->agentinfo_;
}
inline ::dcmd_api::AgentInfo* UiInvalidAgentInfoReply::mutable_agentinfo() {
  set_has_agentinfo();
  if (agentinfo_ == NULL) agentinfo_ = new ::dcmd_api::AgentInfo;
  return agentinfo_;
}
inline ::dcmd_api::AgentInfo* UiInvalidAgentInfoReply::release_agentinfo() {
  clear_has_agentinfo();
  ::dcmd_api::AgentInfo* temp = agentinfo_;
  agentinfo_ = NULL;
  return temp;
}

// optional string err = 3;
inline bool UiInvalidAgentInfoReply::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiInvalidAgentInfoReply::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiInvalidAgentInfoReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiInvalidAgentInfoReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& UiInvalidAgentInfoReply::err() const {
  return *err_;
}
inline void UiInvalidAgentInfoReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiInvalidAgentInfoReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiInvalidAgentInfoReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiInvalidAgentInfoReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* UiInvalidAgentInfoReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiTaskScriptInfo

// required string task_type = 1;
inline bool UiTaskScriptInfo::has_task_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiTaskScriptInfo::set_has_task_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiTaskScriptInfo::clear_has_task_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiTaskScriptInfo::clear_task_type() {
  if (task_type_ != &::google::protobuf::internal::kEmptyString) {
    task_type_->clear();
  }
  clear_has_task_type();
}
inline const ::std::string& UiTaskScriptInfo::task_type() const {
  return *task_type_;
}
inline void UiTaskScriptInfo::set_task_type(const ::std::string& value) {
  set_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    task_type_ = new ::std::string;
  }
  task_type_->assign(value);
}
inline void UiTaskScriptInfo::set_task_type(const char* value) {
  set_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    task_type_ = new ::std::string;
  }
  task_type_->assign(value);
}
inline void UiTaskScriptInfo::set_task_type(const char* value, size_t size) {
  set_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    task_type_ = new ::std::string;
  }
  task_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskScriptInfo::mutable_task_type() {
  set_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    task_type_ = new ::std::string;
  }
  return task_type_;
}
inline ::std::string* UiTaskScriptInfo::release_task_type() {
  clear_has_task_type();
  if (task_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_type_;
    task_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string user = 2;
inline bool UiTaskScriptInfo::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiTaskScriptInfo::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiTaskScriptInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiTaskScriptInfo::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& UiTaskScriptInfo::user() const {
  return *user_;
}
inline void UiTaskScriptInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiTaskScriptInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiTaskScriptInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskScriptInfo::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* UiTaskScriptInfo::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string passwd = 3;
inline bool UiTaskScriptInfo::has_passwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiTaskScriptInfo::set_has_passwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiTaskScriptInfo::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiTaskScriptInfo::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& UiTaskScriptInfo::passwd() const {
  return *passwd_;
}
inline void UiTaskScriptInfo::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiTaskScriptInfo::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiTaskScriptInfo::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskScriptInfo::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* UiTaskScriptInfo::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiTaskScriptInfoReply

// required .dcmd_api.DcmdState state = 1;
inline bool UiTaskScriptInfoReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiTaskScriptInfoReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiTaskScriptInfoReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiTaskScriptInfoReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState UiTaskScriptInfoReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void UiTaskScriptInfoReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional string script = 2;
inline bool UiTaskScriptInfoReply::has_script() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiTaskScriptInfoReply::set_has_script() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiTaskScriptInfoReply::clear_has_script() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiTaskScriptInfoReply::clear_script() {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& UiTaskScriptInfoReply::script() const {
  return *script_;
}
inline void UiTaskScriptInfoReply::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void UiTaskScriptInfoReply::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void UiTaskScriptInfoReply::set_script(const char* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskScriptInfoReply::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  return script_;
}
inline ::std::string* UiTaskScriptInfoReply::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string err = 3;
inline bool UiTaskScriptInfoReply::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiTaskScriptInfoReply::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiTaskScriptInfoReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiTaskScriptInfoReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& UiTaskScriptInfoReply::err() const {
  return *err_;
}
inline void UiTaskScriptInfoReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiTaskScriptInfoReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiTaskScriptInfoReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskScriptInfoReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* UiTaskScriptInfoReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string md5 = 4;
inline bool UiTaskScriptInfoReply::has_md5() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UiTaskScriptInfoReply::set_has_md5() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UiTaskScriptInfoReply::clear_has_md5() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UiTaskScriptInfoReply::clear_md5() {
  if (md5_ != &::google::protobuf::internal::kEmptyString) {
    md5_->clear();
  }
  clear_has_md5();
}
inline const ::std::string& UiTaskScriptInfoReply::md5() const {
  return *md5_;
}
inline void UiTaskScriptInfoReply::set_md5(const ::std::string& value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void UiTaskScriptInfoReply::set_md5(const char* value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void UiTaskScriptInfoReply::set_md5(const char* value, size_t size) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskScriptInfoReply::mutable_md5() {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  return md5_;
}
inline ::std::string* UiTaskScriptInfoReply::release_md5() {
  clear_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = md5_;
    md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiOprScriptInfo

// required string opr_file = 1;
inline bool UiOprScriptInfo::has_opr_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiOprScriptInfo::set_has_opr_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiOprScriptInfo::clear_has_opr_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiOprScriptInfo::clear_opr_file() {
  if (opr_file_ != &::google::protobuf::internal::kEmptyString) {
    opr_file_->clear();
  }
  clear_has_opr_file();
}
inline const ::std::string& UiOprScriptInfo::opr_file() const {
  return *opr_file_;
}
inline void UiOprScriptInfo::set_opr_file(const ::std::string& value) {
  set_has_opr_file();
  if (opr_file_ == &::google::protobuf::internal::kEmptyString) {
    opr_file_ = new ::std::string;
  }
  opr_file_->assign(value);
}
inline void UiOprScriptInfo::set_opr_file(const char* value) {
  set_has_opr_file();
  if (opr_file_ == &::google::protobuf::internal::kEmptyString) {
    opr_file_ = new ::std::string;
  }
  opr_file_->assign(value);
}
inline void UiOprScriptInfo::set_opr_file(const char* value, size_t size) {
  set_has_opr_file();
  if (opr_file_ == &::google::protobuf::internal::kEmptyString) {
    opr_file_ = new ::std::string;
  }
  opr_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiOprScriptInfo::mutable_opr_file() {
  set_has_opr_file();
  if (opr_file_ == &::google::protobuf::internal::kEmptyString) {
    opr_file_ = new ::std::string;
  }
  return opr_file_;
}
inline ::std::string* UiOprScriptInfo::release_opr_file() {
  clear_has_opr_file();
  if (opr_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opr_file_;
    opr_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string user = 2;
inline bool UiOprScriptInfo::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiOprScriptInfo::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiOprScriptInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiOprScriptInfo::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& UiOprScriptInfo::user() const {
  return *user_;
}
inline void UiOprScriptInfo::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiOprScriptInfo::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiOprScriptInfo::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiOprScriptInfo::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* UiOprScriptInfo::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string passwd = 3;
inline bool UiOprScriptInfo::has_passwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiOprScriptInfo::set_has_passwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiOprScriptInfo::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiOprScriptInfo::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& UiOprScriptInfo::passwd() const {
  return *passwd_;
}
inline void UiOprScriptInfo::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiOprScriptInfo::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiOprScriptInfo::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiOprScriptInfo::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* UiOprScriptInfo::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiOprScriptInfoReply

// required .dcmd_api.DcmdState state = 1;
inline bool UiOprScriptInfoReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiOprScriptInfoReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiOprScriptInfoReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiOprScriptInfoReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState UiOprScriptInfoReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void UiOprScriptInfoReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional string script = 2;
inline bool UiOprScriptInfoReply::has_script() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiOprScriptInfoReply::set_has_script() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiOprScriptInfoReply::clear_has_script() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiOprScriptInfoReply::clear_script() {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& UiOprScriptInfoReply::script() const {
  return *script_;
}
inline void UiOprScriptInfoReply::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void UiOprScriptInfoReply::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void UiOprScriptInfoReply::set_script(const char* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiOprScriptInfoReply::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  return script_;
}
inline ::std::string* UiOprScriptInfoReply::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string err = 3;
inline bool UiOprScriptInfoReply::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiOprScriptInfoReply::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiOprScriptInfoReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiOprScriptInfoReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& UiOprScriptInfoReply::err() const {
  return *err_;
}
inline void UiOprScriptInfoReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiOprScriptInfoReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiOprScriptInfoReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiOprScriptInfoReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* UiOprScriptInfoReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string md5 = 4;
inline bool UiOprScriptInfoReply::has_md5() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UiOprScriptInfoReply::set_has_md5() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UiOprScriptInfoReply::clear_has_md5() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UiOprScriptInfoReply::clear_md5() {
  if (md5_ != &::google::protobuf::internal::kEmptyString) {
    md5_->clear();
  }
  clear_has_md5();
}
inline const ::std::string& UiOprScriptInfoReply::md5() const {
  return *md5_;
}
inline void UiOprScriptInfoReply::set_md5(const ::std::string& value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void UiOprScriptInfoReply::set_md5(const char* value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void UiOprScriptInfoReply::set_md5(const char* value, size_t size) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiOprScriptInfoReply::mutable_md5() {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  return md5_;
}
inline ::std::string* UiOprScriptInfoReply::release_md5() {
  clear_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = md5_;
    md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiAgentTaskProcess

// repeated string subtask_id = 1;
inline int UiAgentTaskProcess::subtask_id_size() const {
  return subtask_id_.size();
}
inline void UiAgentTaskProcess::clear_subtask_id() {
  subtask_id_.Clear();
}
inline const ::std::string& UiAgentTaskProcess::subtask_id(int index) const {
  return subtask_id_.Get(index);
}
inline ::std::string* UiAgentTaskProcess::mutable_subtask_id(int index) {
  return subtask_id_.Mutable(index);
}
inline void UiAgentTaskProcess::set_subtask_id(int index, const ::std::string& value) {
  subtask_id_.Mutable(index)->assign(value);
}
inline void UiAgentTaskProcess::set_subtask_id(int index, const char* value) {
  subtask_id_.Mutable(index)->assign(value);
}
inline void UiAgentTaskProcess::set_subtask_id(int index, const char* value, size_t size) {
  subtask_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentTaskProcess::add_subtask_id() {
  return subtask_id_.Add();
}
inline void UiAgentTaskProcess::add_subtask_id(const ::std::string& value) {
  subtask_id_.Add()->assign(value);
}
inline void UiAgentTaskProcess::add_subtask_id(const char* value) {
  subtask_id_.Add()->assign(value);
}
inline void UiAgentTaskProcess::add_subtask_id(const char* value, size_t size) {
  subtask_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UiAgentTaskProcess::subtask_id() const {
  return subtask_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UiAgentTaskProcess::mutable_subtask_id() {
  return &subtask_id_;
}

// required string user = 2;
inline bool UiAgentTaskProcess::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiAgentTaskProcess::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiAgentTaskProcess::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiAgentTaskProcess::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& UiAgentTaskProcess::user() const {
  return *user_;
}
inline void UiAgentTaskProcess::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiAgentTaskProcess::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiAgentTaskProcess::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentTaskProcess::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* UiAgentTaskProcess::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string passwd = 3;
inline bool UiAgentTaskProcess::has_passwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiAgentTaskProcess::set_has_passwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiAgentTaskProcess::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiAgentTaskProcess::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& UiAgentTaskProcess::passwd() const {
  return *passwd_;
}
inline void UiAgentTaskProcess::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiAgentTaskProcess::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiAgentTaskProcess::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentTaskProcess::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* UiAgentTaskProcess::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiAgentTaskProcessReply

// required .dcmd_api.DcmdState state = 1;
inline bool UiAgentTaskProcessReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiAgentTaskProcessReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiAgentTaskProcessReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiAgentTaskProcessReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState UiAgentTaskProcessReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void UiAgentTaskProcessReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// repeated string process = 2;
inline int UiAgentTaskProcessReply::process_size() const {
  return process_.size();
}
inline void UiAgentTaskProcessReply::clear_process() {
  process_.Clear();
}
inline const ::std::string& UiAgentTaskProcessReply::process(int index) const {
  return process_.Get(index);
}
inline ::std::string* UiAgentTaskProcessReply::mutable_process(int index) {
  return process_.Mutable(index);
}
inline void UiAgentTaskProcessReply::set_process(int index, const ::std::string& value) {
  process_.Mutable(index)->assign(value);
}
inline void UiAgentTaskProcessReply::set_process(int index, const char* value) {
  process_.Mutable(index)->assign(value);
}
inline void UiAgentTaskProcessReply::set_process(int index, const char* value, size_t size) {
  process_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentTaskProcessReply::add_process() {
  return process_.Add();
}
inline void UiAgentTaskProcessReply::add_process(const ::std::string& value) {
  process_.Add()->assign(value);
}
inline void UiAgentTaskProcessReply::add_process(const char* value) {
  process_.Add()->assign(value);
}
inline void UiAgentTaskProcessReply::add_process(const char* value, size_t size) {
  process_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UiAgentTaskProcessReply::process() const {
  return process_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UiAgentTaskProcessReply::mutable_process() {
  return &process_;
}

// optional string err = 3;
inline bool UiAgentTaskProcessReply::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiAgentTaskProcessReply::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiAgentTaskProcessReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiAgentTaskProcessReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& UiAgentTaskProcessReply::err() const {
  return *err_;
}
inline void UiAgentTaskProcessReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiAgentTaskProcessReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiAgentTaskProcessReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiAgentTaskProcessReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* UiAgentTaskProcessReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiTaskCmd

// required string task_id = 1;
inline bool UiTaskCmd::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiTaskCmd::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiTaskCmd::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiTaskCmd::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& UiTaskCmd::task_id() const {
  return *task_id_;
}
inline void UiTaskCmd::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void UiTaskCmd::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void UiTaskCmd::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskCmd::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* UiTaskCmd::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string subtask_id = 2;
inline bool UiTaskCmd::has_subtask_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiTaskCmd::set_has_subtask_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiTaskCmd::clear_has_subtask_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiTaskCmd::clear_subtask_id() {
  if (subtask_id_ != &::google::protobuf::internal::kEmptyString) {
    subtask_id_->clear();
  }
  clear_has_subtask_id();
}
inline const ::std::string& UiTaskCmd::subtask_id() const {
  return *subtask_id_;
}
inline void UiTaskCmd::set_subtask_id(const ::std::string& value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void UiTaskCmd::set_subtask_id(const char* value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void UiTaskCmd::set_subtask_id(const char* value, size_t size) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskCmd::mutable_subtask_id() {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  return subtask_id_;
}
inline ::std::string* UiTaskCmd::release_subtask_id() {
  clear_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtask_id_;
    subtask_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ip = 3;
inline bool UiTaskCmd::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiTaskCmd::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiTaskCmd::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiTaskCmd::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& UiTaskCmd::ip() const {
  return *ip_;
}
inline void UiTaskCmd::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UiTaskCmd::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UiTaskCmd::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskCmd::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* UiTaskCmd::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string app_pool = 4;
inline bool UiTaskCmd::has_app_pool() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UiTaskCmd::set_has_app_pool() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UiTaskCmd::clear_has_app_pool() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UiTaskCmd::clear_app_pool() {
  if (app_pool_ != &::google::protobuf::internal::kEmptyString) {
    app_pool_->clear();
  }
  clear_has_app_pool();
}
inline const ::std::string& UiTaskCmd::app_pool() const {
  return *app_pool_;
}
inline void UiTaskCmd::set_app_pool(const ::std::string& value) {
  set_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    app_pool_ = new ::std::string;
  }
  app_pool_->assign(value);
}
inline void UiTaskCmd::set_app_pool(const char* value) {
  set_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    app_pool_ = new ::std::string;
  }
  app_pool_->assign(value);
}
inline void UiTaskCmd::set_app_pool(const char* value, size_t size) {
  set_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    app_pool_ = new ::std::string;
  }
  app_pool_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskCmd::mutable_app_pool() {
  set_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    app_pool_ = new ::std::string;
  }
  return app_pool_;
}
inline ::std::string* UiTaskCmd::release_app_pool() {
  clear_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_pool_;
    app_pool_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .dcmd_api.CmdType cmd_type = 5;
inline bool UiTaskCmd::has_cmd_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UiTaskCmd::set_has_cmd_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UiTaskCmd::clear_has_cmd_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UiTaskCmd::clear_cmd_type() {
  cmd_type_ = 1;
  clear_has_cmd_type();
}
inline dcmd_api::CmdType UiTaskCmd::cmd_type() const {
  return static_cast< dcmd_api::CmdType >(cmd_type_);
}
inline void UiTaskCmd::set_cmd_type(dcmd_api::CmdType value) {
  GOOGLE_DCHECK(dcmd_api::CmdType_IsValid(value));
  set_has_cmd_type();
  cmd_type_ = value;
}

// required string user = 6;
inline bool UiTaskCmd::has_user() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UiTaskCmd::set_has_user() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UiTaskCmd::clear_has_user() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UiTaskCmd::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& UiTaskCmd::user() const {
  return *user_;
}
inline void UiTaskCmd::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiTaskCmd::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiTaskCmd::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskCmd::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* UiTaskCmd::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string passwd = 7;
inline bool UiTaskCmd::has_passwd() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UiTaskCmd::set_has_passwd() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UiTaskCmd::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UiTaskCmd::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& UiTaskCmd::passwd() const {
  return *passwd_;
}
inline void UiTaskCmd::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiTaskCmd::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiTaskCmd::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskCmd::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* UiTaskCmd::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiTaskCmdReply

// required .dcmd_api.DcmdState state = 1;
inline bool UiTaskCmdReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiTaskCmdReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiTaskCmdReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiTaskCmdReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState UiTaskCmdReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void UiTaskCmdReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional string cmd_id = 2;
inline bool UiTaskCmdReply::has_cmd_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiTaskCmdReply::set_has_cmd_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiTaskCmdReply::clear_has_cmd_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiTaskCmdReply::clear_cmd_id() {
  if (cmd_id_ != &::google::protobuf::internal::kEmptyString) {
    cmd_id_->clear();
  }
  clear_has_cmd_id();
}
inline const ::std::string& UiTaskCmdReply::cmd_id() const {
  return *cmd_id_;
}
inline void UiTaskCmdReply::set_cmd_id(const ::std::string& value) {
  set_has_cmd_id();
  if (cmd_id_ == &::google::protobuf::internal::kEmptyString) {
    cmd_id_ = new ::std::string;
  }
  cmd_id_->assign(value);
}
inline void UiTaskCmdReply::set_cmd_id(const char* value) {
  set_has_cmd_id();
  if (cmd_id_ == &::google::protobuf::internal::kEmptyString) {
    cmd_id_ = new ::std::string;
  }
  cmd_id_->assign(value);
}
inline void UiTaskCmdReply::set_cmd_id(const char* value, size_t size) {
  set_has_cmd_id();
  if (cmd_id_ == &::google::protobuf::internal::kEmptyString) {
    cmd_id_ = new ::std::string;
  }
  cmd_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskCmdReply::mutable_cmd_id() {
  set_has_cmd_id();
  if (cmd_id_ == &::google::protobuf::internal::kEmptyString) {
    cmd_id_ = new ::std::string;
  }
  return cmd_id_;
}
inline ::std::string* UiTaskCmdReply::release_cmd_id() {
  clear_has_cmd_id();
  if (cmd_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_id_;
    cmd_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string err = 3;
inline bool UiTaskCmdReply::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiTaskCmdReply::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiTaskCmdReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiTaskCmdReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& UiTaskCmdReply::err() const {
  return *err_;
}
inline void UiTaskCmdReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiTaskCmdReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiTaskCmdReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskCmdReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* UiTaskCmdReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiTaskWatch

// required string task_id = 1;
inline bool UiTaskWatch::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiTaskWatch::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiTaskWatch::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiTaskWatch::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& UiTaskWatch::task_id() const {
  return *task_id_;
}
inline void UiTaskWatch::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void UiTaskWatch::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void UiTaskWatch::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskWatch::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* UiTaskWatch::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string app_pool = 2;
inline bool UiTaskWatch::has_app_pool() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiTaskWatch::set_has_app_pool() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiTaskWatch::clear_has_app_pool() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiTaskWatch::clear_app_pool() {
  if (app_pool_ != &::google::protobuf::internal::kEmptyString) {
    app_pool_->clear();
  }
  clear_has_app_pool();
}
inline const ::std::string& UiTaskWatch::app_pool() const {
  return *app_pool_;
}
inline void UiTaskWatch::set_app_pool(const ::std::string& value) {
  set_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    app_pool_ = new ::std::string;
  }
  app_pool_->assign(value);
}
inline void UiTaskWatch::set_app_pool(const char* value) {
  set_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    app_pool_ = new ::std::string;
  }
  app_pool_->assign(value);
}
inline void UiTaskWatch::set_app_pool(const char* value, size_t size) {
  set_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    app_pool_ = new ::std::string;
  }
  app_pool_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskWatch::mutable_app_pool() {
  set_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    app_pool_ = new ::std::string;
  }
  return app_pool_;
}
inline ::std::string* UiTaskWatch::release_app_pool() {
  clear_has_app_pool();
  if (app_pool_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_pool_;
    app_pool_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string subtask_id = 3;
inline bool UiTaskWatch::has_subtask_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiTaskWatch::set_has_subtask_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiTaskWatch::clear_has_subtask_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiTaskWatch::clear_subtask_id() {
  if (subtask_id_ != &::google::protobuf::internal::kEmptyString) {
    subtask_id_->clear();
  }
  clear_has_subtask_id();
}
inline const ::std::string& UiTaskWatch::subtask_id() const {
  return *subtask_id_;
}
inline void UiTaskWatch::set_subtask_id(const ::std::string& value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void UiTaskWatch::set_subtask_id(const char* value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void UiTaskWatch::set_subtask_id(const char* value, size_t size) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskWatch::mutable_subtask_id() {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  return subtask_id_;
}
inline ::std::string* UiTaskWatch::release_subtask_id() {
  clear_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtask_id_;
    subtask_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string user = 4;
inline bool UiTaskWatch::has_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UiTaskWatch::set_has_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UiTaskWatch::clear_has_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UiTaskWatch::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& UiTaskWatch::user() const {
  return *user_;
}
inline void UiTaskWatch::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiTaskWatch::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void UiTaskWatch::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskWatch::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* UiTaskWatch::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string passwd = 5;
inline bool UiTaskWatch::has_passwd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UiTaskWatch::set_has_passwd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UiTaskWatch::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UiTaskWatch::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& UiTaskWatch::passwd() const {
  return *passwd_;
}
inline void UiTaskWatch::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiTaskWatch::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UiTaskWatch::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskWatch::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* UiTaskWatch::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UiTaskWatchReply

// required .dcmd_api.DcmdState watch_state = 1;
inline bool UiTaskWatchReply::has_watch_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UiTaskWatchReply::set_has_watch_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UiTaskWatchReply::clear_has_watch_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UiTaskWatchReply::clear_watch_state() {
  watch_state_ = 0;
  clear_has_watch_state();
}
inline dcmd_api::DcmdState UiTaskWatchReply::watch_state() const {
  return static_cast< dcmd_api::DcmdState >(watch_state_);
}
inline void UiTaskWatchReply::set_watch_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_watch_state();
  watch_state_ = value;
}

// optional string err = 2;
inline bool UiTaskWatchReply::has_err() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UiTaskWatchReply::set_has_err() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UiTaskWatchReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UiTaskWatchReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& UiTaskWatchReply::err() const {
  return *err_;
}
inline void UiTaskWatchReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiTaskWatchReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void UiTaskWatchReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UiTaskWatchReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* UiTaskWatchReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .dcmd_api.TaskState task_state = 3;
inline bool UiTaskWatchReply::has_task_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UiTaskWatchReply::set_has_task_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UiTaskWatchReply::clear_has_task_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UiTaskWatchReply::clear_task_state() {
  task_state_ = 0;
  clear_has_task_state();
}
inline dcmd_api::TaskState UiTaskWatchReply::task_state() const {
  return static_cast< dcmd_api::TaskState >(task_state_);
}
inline void UiTaskWatchReply::set_task_state(dcmd_api::TaskState value) {
  GOOGLE_DCHECK(dcmd_api::TaskState_IsValid(value));
  set_has_task_state();
  task_state_ = value;
}

// optional .dcmd_api.AppPoolState app_pool_state = 4;
inline bool UiTaskWatchReply::has_app_pool_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UiTaskWatchReply::set_has_app_pool_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UiTaskWatchReply::clear_has_app_pool_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UiTaskWatchReply::clear_app_pool_state() {
  app_pool_state_ = 0;
  clear_has_app_pool_state();
}
inline dcmd_api::AppPoolState UiTaskWatchReply::app_pool_state() const {
  return static_cast< dcmd_api::AppPoolState >(app_pool_state_);
}
inline void UiTaskWatchReply::set_app_pool_state(dcmd_api::AppPoolState value) {
  GOOGLE_DCHECK(dcmd_api::AppPoolState_IsValid(value));
  set_has_app_pool_state();
  app_pool_state_ = value;
}

// optional .dcmd_api.SubTaskState subtask_state = 5;
inline bool UiTaskWatchReply::has_subtask_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UiTaskWatchReply::set_has_subtask_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UiTaskWatchReply::clear_has_subtask_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UiTaskWatchReply::clear_subtask_state() {
  subtask_state_ = 0;
  clear_has_subtask_state();
}
inline dcmd_api::SubTaskState UiTaskWatchReply::subtask_state() const {
  return static_cast< dcmd_api::SubTaskState >(subtask_state_);
}
inline void UiTaskWatchReply::set_subtask_state(dcmd_api::SubTaskState value) {
  GOOGLE_DCHECK(dcmd_api::SubTaskState_IsValid(value));
  set_has_subtask_state();
  subtask_state_ = value;
}

// optional int32 success_subtask = 6;
inline bool UiTaskWatchReply::has_success_subtask() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UiTaskWatchReply::set_has_success_subtask() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UiTaskWatchReply::clear_has_success_subtask() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UiTaskWatchReply::clear_success_subtask() {
  success_subtask_ = 0;
  clear_has_success_subtask();
}
inline ::google::protobuf::int32 UiTaskWatchReply::success_subtask() const {
  return success_subtask_;
}
inline void UiTaskWatchReply::set_success_subtask(::google::protobuf::int32 value) {
  set_has_success_subtask();
  success_subtask_ = value;
}

// optional int32 failed_subtask = 7;
inline bool UiTaskWatchReply::has_failed_subtask() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UiTaskWatchReply::set_has_failed_subtask() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UiTaskWatchReply::clear_has_failed_subtask() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UiTaskWatchReply::clear_failed_subtask() {
  failed_subtask_ = 0;
  clear_has_failed_subtask();
}
inline ::google::protobuf::int32 UiTaskWatchReply::failed_subtask() const {
  return failed_subtask_;
}
inline void UiTaskWatchReply::set_failed_subtask(::google::protobuf::int32 value) {
  set_has_failed_subtask();
  failed_subtask_ = value;
}

// optional int32 doing_subtask = 8;
inline bool UiTaskWatchReply::has_doing_subtask() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UiTaskWatchReply::set_has_doing_subtask() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UiTaskWatchReply::clear_has_doing_subtask() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UiTaskWatchReply::clear_doing_subtask() {
  doing_subtask_ = 0;
  clear_has_doing_subtask();
}
inline ::google::protobuf::int32 UiTaskWatchReply::doing_subtask() const {
  return doing_subtask_;
}
inline void UiTaskWatchReply::set_doing_subtask(::google::protobuf::int32 value) {
  set_has_doing_subtask();
  doing_subtask_ = value;
}

// optional int32 cancel_subtask = 9;
inline bool UiTaskWatchReply::has_cancel_subtask() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UiTaskWatchReply::set_has_cancel_subtask() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UiTaskWatchReply::clear_has_cancel_subtask() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UiTaskWatchReply::clear_cancel_subtask() {
  cancel_subtask_ = 0;
  clear_has_cancel_subtask();
}
inline ::google::protobuf::int32 UiTaskWatchReply::cancel_subtask() const {
  return cancel_subtask_;
}
inline void UiTaskWatchReply::set_cancel_subtask(::google::protobuf::int32 value) {
  set_has_cancel_subtask();
  cancel_subtask_ = value;
}

// optional int32 undo_subtask = 10;
inline bool UiTaskWatchReply::has_undo_subtask() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UiTaskWatchReply::set_has_undo_subtask() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UiTaskWatchReply::clear_has_undo_subtask() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UiTaskWatchReply::clear_undo_subtask() {
  undo_subtask_ = 0;
  clear_has_undo_subtask();
}
inline ::google::protobuf::int32 UiTaskWatchReply::undo_subtask() const {
  return undo_subtask_;
}
inline void UiTaskWatchReply::set_undo_subtask(::google::protobuf::int32 value) {
  set_has_undo_subtask();
  undo_subtask_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dcmd_api

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< dcmd_api::DcmdState>() {
  return dcmd_api::DcmdState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< dcmd_api::AgentState>() {
  return dcmd_api::AgentState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< dcmd_api::TaskState>() {
  return dcmd_api::TaskState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< dcmd_api::AppPoolState>() {
  return dcmd_api::AppPoolState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< dcmd_api::SubTaskState>() {
  return dcmd_api::SubTaskState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< dcmd_api::CmdType>() {
  return dcmd_api::CmdType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dcmd_2eproto__INCLUDED
