// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dcmd_agent.proto

#ifndef PROTOBUF_dcmd_5fagent_2eproto__INCLUDED
#define PROTOBUF_dcmd_5fagent_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "dcmd_cmn.pb.h"
// @@protoc_insertion_point(includes)

namespace dcmd_api {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_dcmd_5fagent_2eproto();
void protobuf_AssignDesc_dcmd_5fagent_2eproto();
void protobuf_ShutdownFile_dcmd_5fagent_2eproto();

class AgentReport;
class AgentReportReply;
class AgentMasterNoticeReply;
class AgentTaskCmd;
class AgentTaskCmdReply;
class AgentSubTaskProcess;
class AgentTaskResult;
class AgentTaskResultReply;
class AgentOprCmd;
class AgentTaskOutput;
class AgentTaskOutputReply;
class AgentRunningTask;
class AgentRunningTaskReply;
class AgentRunningOpr;
class AgentRunningOprReply;
class InvalidMsg;

// ===================================================================

class AgentReport : public ::google::protobuf::Message {
 public:
  AgentReport();
  virtual ~AgentReport();
  
  AgentReport(const AgentReport& from);
  
  inline AgentReport& operator=(const AgentReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentReport& default_instance();
  
  void Swap(AgentReport* other);
  
  // implements Message ----------------------------------------------
  
  AgentReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentReport& from);
  void MergeFrom(const AgentReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // repeated string agent_ips = 2;
  inline int agent_ips_size() const;
  inline void clear_agent_ips();
  static const int kAgentIpsFieldNumber = 2;
  inline const ::std::string& agent_ips(int index) const;
  inline ::std::string* mutable_agent_ips(int index);
  inline void set_agent_ips(int index, const ::std::string& value);
  inline void set_agent_ips(int index, const char* value);
  inline void set_agent_ips(int index, const char* value, size_t size);
  inline ::std::string* add_agent_ips();
  inline void add_agent_ips(const ::std::string& value);
  inline void add_agent_ips(const char* value);
  inline void add_agent_ips(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& agent_ips() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_agent_ips();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentReport)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> agent_ips_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentReport* default_instance_;
};
// -------------------------------------------------------------------

class AgentReportReply : public ::google::protobuf::Message {
 public:
  AgentReportReply();
  virtual ~AgentReportReply();
  
  AgentReportReply(const AgentReportReply& from);
  
  inline AgentReportReply& operator=(const AgentReportReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentReportReply& default_instance();
  
  void Swap(AgentReportReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentReportReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentReportReply& from);
  void MergeFrom(const AgentReportReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // optional string err = 2;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 2;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // optional int32 heatbeat = 3;
  inline bool has_heatbeat() const;
  inline void clear_heatbeat();
  static const int kHeatbeatFieldNumber = 3;
  inline ::google::protobuf::int32 heatbeat() const;
  inline void set_heatbeat(::google::protobuf::int32 value);
  
  // optional int32 package_size = 4;
  inline bool has_package_size() const;
  inline void clear_package_size();
  static const int kPackageSizeFieldNumber = 4;
  inline ::google::protobuf::int32 package_size() const;
  inline void set_package_size(::google::protobuf::int32 value);
  
  // optional int32 opr_queue_threshold = 5;
  inline bool has_opr_queue_threshold() const;
  inline void clear_opr_queue_threshold();
  static const int kOprQueueThresholdFieldNumber = 5;
  inline ::google::protobuf::int32 opr_queue_threshold() const;
  inline void set_opr_queue_threshold(::google::protobuf::int32 value);
  
  // optional int32 opr_overflow_threshold = 6;
  inline bool has_opr_overflow_threshold() const;
  inline void clear_opr_overflow_threshold();
  static const int kOprOverflowThresholdFieldNumber = 6;
  inline ::google::protobuf::int32 opr_overflow_threshold() const;
  inline void set_opr_overflow_threshold(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentReportReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_err();
  inline void clear_has_err();
  inline void set_has_heatbeat();
  inline void clear_has_heatbeat();
  inline void set_has_package_size();
  inline void clear_has_package_size();
  inline void set_has_opr_queue_threshold();
  inline void clear_has_opr_queue_threshold();
  inline void set_has_opr_overflow_threshold();
  inline void clear_has_opr_overflow_threshold();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* err_;
  int state_;
  ::google::protobuf::int32 heatbeat_;
  ::google::protobuf::int32 package_size_;
  ::google::protobuf::int32 opr_queue_threshold_;
  ::google::protobuf::int32 opr_overflow_threshold_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentReportReply* default_instance_;
};
// -------------------------------------------------------------------

class AgentMasterNoticeReply : public ::google::protobuf::Message {
 public:
  AgentMasterNoticeReply();
  virtual ~AgentMasterNoticeReply();
  
  AgentMasterNoticeReply(const AgentMasterNoticeReply& from);
  
  inline AgentMasterNoticeReply& operator=(const AgentMasterNoticeReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentMasterNoticeReply& default_instance();
  
  void Swap(AgentMasterNoticeReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentMasterNoticeReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentMasterNoticeReply& from);
  void MergeFrom(const AgentMasterNoticeReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string cmd = 1;
  inline int cmd_size() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd(int index) const;
  inline ::std::string* mutable_cmd(int index);
  inline void set_cmd(int index, const ::std::string& value);
  inline void set_cmd(int index, const char* value);
  inline void set_cmd(int index, const char* value, size_t size);
  inline ::std::string* add_cmd();
  inline void add_cmd(const ::std::string& value);
  inline void add_cmd(const char* value);
  inline void add_cmd(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& cmd() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cmd();
  
  // repeated .dcmd_api.SubTaskProcess subtask_process = 2;
  inline int subtask_process_size() const;
  inline void clear_subtask_process();
  static const int kSubtaskProcessFieldNumber = 2;
  inline const ::dcmd_api::SubTaskProcess& subtask_process(int index) const;
  inline ::dcmd_api::SubTaskProcess* mutable_subtask_process(int index);
  inline ::dcmd_api::SubTaskProcess* add_subtask_process();
  inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskProcess >&
      subtask_process() const;
  inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskProcess >*
      mutable_subtask_process();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentMasterNoticeReply)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> cmd_;
  ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskProcess > subtask_process_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentMasterNoticeReply* default_instance_;
};
// -------------------------------------------------------------------

class AgentTaskCmd : public ::google::protobuf::Message {
 public:
  AgentTaskCmd();
  virtual ~AgentTaskCmd();
  
  AgentTaskCmd(const AgentTaskCmd& from);
  
  inline AgentTaskCmd& operator=(const AgentTaskCmd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentTaskCmd& default_instance();
  
  void Swap(AgentTaskCmd* other);
  
  // implements Message ----------------------------------------------
  
  AgentTaskCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentTaskCmd& from);
  void MergeFrom(const AgentTaskCmd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  
  // required string task_cmd = 2;
  inline bool has_task_cmd() const;
  inline void clear_task_cmd();
  static const int kTaskCmdFieldNumber = 2;
  inline const ::std::string& task_cmd() const;
  inline void set_task_cmd(const ::std::string& value);
  inline void set_task_cmd(const char* value);
  inline void set_task_cmd(const char* value, size_t size);
  inline ::std::string* mutable_task_cmd();
  inline ::std::string* release_task_cmd();
  
  // required .dcmd_api.CmdType cmd_type = 3;
  inline bool has_cmd_type() const;
  inline void clear_cmd_type();
  static const int kCmdTypeFieldNumber = 3;
  inline dcmd_api::CmdType cmd_type() const;
  inline void set_cmd_type(dcmd_api::CmdType value);
  
  // optional string task_id = 4;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 4;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // optional string subtask_id = 5;
  inline bool has_subtask_id() const;
  inline void clear_subtask_id();
  static const int kSubtaskIdFieldNumber = 5;
  inline const ::std::string& subtask_id() const;
  inline void set_subtask_id(const ::std::string& value);
  inline void set_subtask_id(const char* value);
  inline void set_subtask_id(const char* value, size_t size);
  inline ::std::string* mutable_subtask_id();
  inline ::std::string* release_subtask_id();
  
  // optional string ip = 6;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 6;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // optional string svr_name = 7;
  inline bool has_svr_name() const;
  inline void clear_svr_name();
  static const int kSvrNameFieldNumber = 7;
  inline const ::std::string& svr_name() const;
  inline void set_svr_name(const ::std::string& value);
  inline void set_svr_name(const char* value);
  inline void set_svr_name(const char* value, size_t size);
  inline ::std::string* mutable_svr_name();
  inline ::std::string* release_svr_name();
  
  // optional string svr_pool = 8;
  inline bool has_svr_pool() const;
  inline void clear_svr_pool();
  static const int kSvrPoolFieldNumber = 8;
  inline const ::std::string& svr_pool() const;
  inline void set_svr_pool(const ::std::string& value);
  inline void set_svr_pool(const char* value);
  inline void set_svr_pool(const char* value, size_t size);
  inline ::std::string* mutable_svr_pool();
  inline ::std::string* release_svr_pool();
  
  // optional string svr_ver = 9;
  inline bool has_svr_ver() const;
  inline void clear_svr_ver();
  static const int kSvrVerFieldNumber = 9;
  inline const ::std::string& svr_ver() const;
  inline void set_svr_ver(const ::std::string& value);
  inline void set_svr_ver(const char* value);
  inline void set_svr_ver(const char* value, size_t size);
  inline ::std::string* mutable_svr_ver();
  inline ::std::string* release_svr_ver();
  
  // optional string svr_repo = 10;
  inline bool has_svr_repo() const;
  inline void clear_svr_repo();
  static const int kSvrRepoFieldNumber = 10;
  inline const ::std::string& svr_repo() const;
  inline void set_svr_repo(const ::std::string& value);
  inline void set_svr_repo(const char* value);
  inline void set_svr_repo(const char* value, size_t size);
  inline ::std::string* mutable_svr_repo();
  inline ::std::string* release_svr_repo();
  
  // optional string svr_user = 11;
  inline bool has_svr_user() const;
  inline void clear_svr_user();
  static const int kSvrUserFieldNumber = 11;
  inline const ::std::string& svr_user() const;
  inline void set_svr_user(const ::std::string& value);
  inline void set_svr_user(const char* value);
  inline void set_svr_user(const char* value, size_t size);
  inline ::std::string* mutable_svr_user();
  inline ::std::string* release_svr_user();
  
  // optional string svr_env_ver = 12;
  inline bool has_svr_env_ver() const;
  inline void clear_svr_env_ver();
  static const int kSvrEnvVerFieldNumber = 12;
  inline const ::std::string& svr_env_ver() const;
  inline void set_svr_env_ver(const ::std::string& value);
  inline void set_svr_env_ver(const char* value);
  inline void set_svr_env_ver(const char* value, size_t size);
  inline ::std::string* mutable_svr_env_ver();
  inline ::std::string* release_svr_env_ver();
  
  // optional bool update_env = 13;
  inline bool has_update_env() const;
  inline void clear_update_env();
  static const int kUpdateEnvFieldNumber = 13;
  inline bool update_env() const;
  inline void set_update_env(bool value);
  
  // optional bool update_ver = 14;
  inline bool has_update_ver() const;
  inline void clear_update_ver();
  static const int kUpdateVerFieldNumber = 14;
  inline bool update_ver() const;
  inline void set_update_ver(bool value);
  
  // optional bool output_process = 15;
  inline bool has_output_process() const;
  inline void clear_output_process();
  static const int kOutputProcessFieldNumber = 15;
  inline bool output_process() const;
  inline void set_output_process(bool value);
  
  // optional string script = 16;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 16;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const char* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  
  // repeated .dcmd_api.KeyValue task_arg = 17;
  inline int task_arg_size() const;
  inline void clear_task_arg();
  static const int kTaskArgFieldNumber = 17;
  inline const ::dcmd_api::KeyValue& task_arg(int index) const;
  inline ::dcmd_api::KeyValue* mutable_task_arg(int index);
  inline ::dcmd_api::KeyValue* add_task_arg();
  inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >&
      task_arg() const;
  inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >*
      mutable_task_arg();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentTaskCmd)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_task_cmd();
  inline void clear_has_task_cmd();
  inline void set_has_cmd_type();
  inline void clear_has_cmd_type();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_subtask_id();
  inline void clear_has_subtask_id();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_svr_name();
  inline void clear_has_svr_name();
  inline void set_has_svr_pool();
  inline void clear_has_svr_pool();
  inline void set_has_svr_ver();
  inline void clear_has_svr_ver();
  inline void set_has_svr_repo();
  inline void clear_has_svr_repo();
  inline void set_has_svr_user();
  inline void clear_has_svr_user();
  inline void set_has_svr_env_ver();
  inline void clear_has_svr_env_ver();
  inline void set_has_update_env();
  inline void clear_has_update_env();
  inline void set_has_update_ver();
  inline void clear_has_update_ver();
  inline void set_has_output_process();
  inline void clear_has_output_process();
  inline void set_has_script();
  inline void clear_has_script();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cmd_;
  ::std::string* task_cmd_;
  ::std::string* task_id_;
  ::std::string* subtask_id_;
  ::std::string* ip_;
  ::std::string* svr_name_;
  ::std::string* svr_pool_;
  ::std::string* svr_ver_;
  ::std::string* svr_repo_;
  ::std::string* svr_user_;
  int cmd_type_;
  bool update_env_;
  bool update_ver_;
  bool output_process_;
  ::std::string* svr_env_ver_;
  ::std::string* script_;
  ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue > task_arg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentTaskCmd* default_instance_;
};
// -------------------------------------------------------------------

class AgentTaskCmdReply : public ::google::protobuf::Message {
 public:
  AgentTaskCmdReply();
  virtual ~AgentTaskCmdReply();
  
  AgentTaskCmdReply(const AgentTaskCmdReply& from);
  
  inline AgentTaskCmdReply& operator=(const AgentTaskCmdReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentTaskCmdReply& default_instance();
  
  void Swap(AgentTaskCmdReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentTaskCmdReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentTaskCmdReply& from);
  void MergeFrom(const AgentTaskCmdReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentTaskCmdReply)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentTaskCmdReply* default_instance_;
};
// -------------------------------------------------------------------

class AgentSubTaskProcess : public ::google::protobuf::Message {
 public:
  AgentSubTaskProcess();
  virtual ~AgentSubTaskProcess();
  
  AgentSubTaskProcess(const AgentSubTaskProcess& from);
  
  inline AgentSubTaskProcess& operator=(const AgentSubTaskProcess& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentSubTaskProcess& default_instance();
  
  void Swap(AgentSubTaskProcess* other);
  
  // implements Message ----------------------------------------------
  
  AgentSubTaskProcess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentSubTaskProcess& from);
  void MergeFrom(const AgentSubTaskProcess& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // required string subtask_id = 2;
  inline bool has_subtask_id() const;
  inline void clear_subtask_id();
  static const int kSubtaskIdFieldNumber = 2;
  inline const ::std::string& subtask_id() const;
  inline void set_subtask_id(const ::std::string& value);
  inline void set_subtask_id(const char* value);
  inline void set_subtask_id(const char* value, size_t size);
  inline ::std::string* mutable_subtask_id();
  inline ::std::string* release_subtask_id();
  
  // required string process = 3;
  inline bool has_process() const;
  inline void clear_process();
  static const int kProcessFieldNumber = 3;
  inline const ::std::string& process() const;
  inline void set_process(const ::std::string& value);
  inline void set_process(const char* value);
  inline void set_process(const char* value, size_t size);
  inline ::std::string* mutable_process();
  inline ::std::string* release_process();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentSubTaskProcess)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_subtask_id();
  inline void clear_has_subtask_id();
  inline void set_has_process();
  inline void clear_has_process();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* task_id_;
  ::std::string* subtask_id_;
  ::std::string* process_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentSubTaskProcess* default_instance_;
};
// -------------------------------------------------------------------

class AgentTaskResult : public ::google::protobuf::Message {
 public:
  AgentTaskResult();
  virtual ~AgentTaskResult();
  
  AgentTaskResult(const AgentTaskResult& from);
  
  inline AgentTaskResult& operator=(const AgentTaskResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentTaskResult& default_instance();
  
  void Swap(AgentTaskResult* other);
  
  // implements Message ----------------------------------------------
  
  AgentTaskResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentTaskResult& from);
  void MergeFrom(const AgentTaskResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  
  // required string task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // required string subtask_id = 3;
  inline bool has_subtask_id() const;
  inline void clear_subtask_id();
  static const int kSubtaskIdFieldNumber = 3;
  inline const ::std::string& subtask_id() const;
  inline void set_subtask_id(const ::std::string& value);
  inline void set_subtask_id(const char* value);
  inline void set_subtask_id(const char* value, size_t size);
  inline ::std::string* mutable_subtask_id();
  inline ::std::string* release_subtask_id();
  
  // required bool success = 4;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 4;
  inline bool success() const;
  inline void set_success(bool value);
  
  // optional string err = 5;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 5;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // optional string process = 6;
  inline bool has_process() const;
  inline void clear_process();
  static const int kProcessFieldNumber = 6;
  inline const ::std::string& process() const;
  inline void set_process(const ::std::string& value);
  inline void set_process(const char* value);
  inline void set_process(const char* value, size_t size);
  inline ::std::string* mutable_process();
  inline ::std::string* release_process();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentTaskResult)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_subtask_id();
  inline void clear_has_subtask_id();
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_err();
  inline void clear_has_err();
  inline void set_has_process();
  inline void clear_has_process();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cmd_;
  ::std::string* task_id_;
  ::std::string* subtask_id_;
  ::std::string* err_;
  ::std::string* process_;
  bool success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentTaskResult* default_instance_;
};
// -------------------------------------------------------------------

class AgentTaskResultReply : public ::google::protobuf::Message {
 public:
  AgentTaskResultReply();
  virtual ~AgentTaskResultReply();
  
  AgentTaskResultReply(const AgentTaskResultReply& from);
  
  inline AgentTaskResultReply& operator=(const AgentTaskResultReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentTaskResultReply& default_instance();
  
  void Swap(AgentTaskResultReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentTaskResultReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentTaskResultReply& from);
  void MergeFrom(const AgentTaskResultReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentTaskResultReply)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cmd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentTaskResultReply* default_instance_;
};
// -------------------------------------------------------------------

class AgentOprCmd : public ::google::protobuf::Message {
 public:
  AgentOprCmd();
  virtual ~AgentOprCmd();
  
  AgentOprCmd(const AgentOprCmd& from);
  
  inline AgentOprCmd& operator=(const AgentOprCmd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentOprCmd& default_instance();
  
  void Swap(AgentOprCmd* other);
  
  // implements Message ----------------------------------------------
  
  AgentOprCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentOprCmd& from);
  void MergeFrom(const AgentOprCmd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string opr_id = 1;
  inline bool has_opr_id() const;
  inline void clear_opr_id();
  static const int kOprIdFieldNumber = 1;
  inline const ::std::string& opr_id() const;
  inline void set_opr_id(const ::std::string& value);
  inline void set_opr_id(const char* value);
  inline void set_opr_id(const char* value, size_t size);
  inline ::std::string* mutable_opr_id();
  inline ::std::string* release_opr_id();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string run_user = 3;
  inline bool has_run_user() const;
  inline void clear_run_user();
  static const int kRunUserFieldNumber = 3;
  inline const ::std::string& run_user() const;
  inline void set_run_user(const ::std::string& value);
  inline void set_run_user(const char* value);
  inline void set_run_user(const char* value, size_t size);
  inline ::std::string* mutable_run_user();
  inline ::std::string* release_run_user();
  
  // required int32 timeout = 4;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 4;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);
  
  // required string script = 5;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 5;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const char* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  
  // repeated .dcmd_api.KeyValue args = 6;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 6;
  inline const ::dcmd_api::KeyValue& args(int index) const;
  inline ::dcmd_api::KeyValue* mutable_args(int index);
  inline ::dcmd_api::KeyValue* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentOprCmd)
 private:
  inline void set_has_opr_id();
  inline void clear_has_opr_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_run_user();
  inline void clear_has_run_user();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_script();
  inline void clear_has_script();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* opr_id_;
  ::std::string* name_;
  ::std::string* run_user_;
  ::std::string* script_;
  ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue > args_;
  ::google::protobuf::int32 timeout_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentOprCmd* default_instance_;
};
// -------------------------------------------------------------------

class AgentTaskOutput : public ::google::protobuf::Message {
 public:
  AgentTaskOutput();
  virtual ~AgentTaskOutput();
  
  AgentTaskOutput(const AgentTaskOutput& from);
  
  inline AgentTaskOutput& operator=(const AgentTaskOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentTaskOutput& default_instance();
  
  void Swap(AgentTaskOutput* other);
  
  // implements Message ----------------------------------------------
  
  AgentTaskOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentTaskOutput& from);
  void MergeFrom(const AgentTaskOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string subtask_id = 1;
  inline bool has_subtask_id() const;
  inline void clear_subtask_id();
  static const int kSubtaskIdFieldNumber = 1;
  inline const ::std::string& subtask_id() const;
  inline void set_subtask_id(const ::std::string& value);
  inline void set_subtask_id(const char* value);
  inline void set_subtask_id(const char* value, size_t size);
  inline ::std::string* mutable_subtask_id();
  inline ::std::string* release_subtask_id();
  
  // required int32 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);
  
  // optional string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentTaskOutput)
 private:
  inline void set_has_subtask_id();
  inline void clear_has_subtask_id();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_ip();
  inline void clear_has_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* subtask_id_;
  ::std::string* ip_;
  ::google::protobuf::int32 offset_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentTaskOutput* default_instance_;
};
// -------------------------------------------------------------------

class AgentTaskOutputReply : public ::google::protobuf::Message {
 public:
  AgentTaskOutputReply();
  virtual ~AgentTaskOutputReply();
  
  AgentTaskOutputReply(const AgentTaskOutputReply& from);
  
  inline AgentTaskOutputReply& operator=(const AgentTaskOutputReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentTaskOutputReply& default_instance();
  
  void Swap(AgentTaskOutputReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentTaskOutputReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentTaskOutputReply& from);
  void MergeFrom(const AgentTaskOutputReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // required string result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const char* value, size_t size);
  inline ::std::string* mutable_result();
  inline ::std::string* release_result();
  
  // required int32 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);
  
  // optional string err = 4;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 4;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentTaskOutputReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* result_;
  int state_;
  ::google::protobuf::int32 offset_;
  ::std::string* err_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentTaskOutputReply* default_instance_;
};
// -------------------------------------------------------------------

class AgentRunningTask : public ::google::protobuf::Message {
 public:
  AgentRunningTask();
  virtual ~AgentRunningTask();
  
  AgentRunningTask(const AgentRunningTask& from);
  
  inline AgentRunningTask& operator=(const AgentRunningTask& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentRunningTask& default_instance();
  
  void Swap(AgentRunningTask* other);
  
  // implements Message ----------------------------------------------
  
  AgentRunningTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentRunningTask& from);
  void MergeFrom(const AgentRunningTask& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // optional string svr_name = 2;
  inline bool has_svr_name() const;
  inline void clear_svr_name();
  static const int kSvrNameFieldNumber = 2;
  inline const ::std::string& svr_name() const;
  inline void set_svr_name(const ::std::string& value);
  inline void set_svr_name(const char* value);
  inline void set_svr_name(const char* value, size_t size);
  inline ::std::string* mutable_svr_name();
  inline ::std::string* release_svr_name();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentRunningTask)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_svr_name();
  inline void clear_has_svr_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_;
  ::std::string* svr_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentRunningTask* default_instance_;
};
// -------------------------------------------------------------------

class AgentRunningTaskReply : public ::google::protobuf::Message {
 public:
  AgentRunningTaskReply();
  virtual ~AgentRunningTaskReply();
  
  AgentRunningTaskReply(const AgentRunningTaskReply& from);
  
  inline AgentRunningTaskReply& operator=(const AgentRunningTaskReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentRunningTaskReply& default_instance();
  
  void Swap(AgentRunningTaskReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentRunningTaskReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentRunningTaskReply& from);
  void MergeFrom(const AgentRunningTaskReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // repeated .dcmd_api.SubTaskInfo result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::dcmd_api::SubTaskInfo& result(int index) const;
  inline ::dcmd_api::SubTaskInfo* mutable_result(int index);
  inline ::dcmd_api::SubTaskInfo* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo >*
      mutable_result();
  
  // optional string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentRunningTaskReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo > result_;
  ::std::string* err_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentRunningTaskReply* default_instance_;
};
// -------------------------------------------------------------------

class AgentRunningOpr : public ::google::protobuf::Message {
 public:
  AgentRunningOpr();
  virtual ~AgentRunningOpr();
  
  AgentRunningOpr(const AgentRunningOpr& from);
  
  inline AgentRunningOpr& operator=(const AgentRunningOpr& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentRunningOpr& default_instance();
  
  void Swap(AgentRunningOpr* other);
  
  // implements Message ----------------------------------------------
  
  AgentRunningOpr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentRunningOpr& from);
  void MergeFrom(const AgentRunningOpr& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentRunningOpr)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentRunningOpr* default_instance_;
};
// -------------------------------------------------------------------

class AgentRunningOprReply : public ::google::protobuf::Message {
 public:
  AgentRunningOprReply();
  virtual ~AgentRunningOprReply();
  
  AgentRunningOprReply(const AgentRunningOprReply& from);
  
  inline AgentRunningOprReply& operator=(const AgentRunningOprReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentRunningOprReply& default_instance();
  
  void Swap(AgentRunningOprReply* other);
  
  // implements Message ----------------------------------------------
  
  AgentRunningOprReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentRunningOprReply& from);
  void MergeFrom(const AgentRunningOprReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dcmd_api.DcmdState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline dcmd_api::DcmdState state() const;
  inline void set_state(dcmd_api::DcmdState value);
  
  // repeated .dcmd_api.OprInfo result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::dcmd_api::OprInfo& result(int index) const;
  inline ::dcmd_api::OprInfo* mutable_result(int index);
  inline ::dcmd_api::OprInfo* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo >*
      mutable_result();
  
  // optional string err = 3;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 3;
  inline const ::std::string& err() const;
  inline void set_err(const ::std::string& value);
  inline void set_err(const char* value);
  inline void set_err(const char* value, size_t size);
  inline ::std::string* mutable_err();
  inline ::std::string* release_err();
  
  // @@protoc_insertion_point(class_scope:dcmd_api.AgentRunningOprReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_err();
  inline void clear_has_err();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo > result_;
  ::std::string* err_;
  int state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static AgentRunningOprReply* default_instance_;
};
// -------------------------------------------------------------------

class InvalidMsg : public ::google::protobuf::Message {
 public:
  InvalidMsg();
  virtual ~InvalidMsg();
  
  InvalidMsg(const InvalidMsg& from);
  
  inline InvalidMsg& operator=(const InvalidMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvalidMsg& default_instance();
  
  void Swap(InvalidMsg* other);
  
  // implements Message ----------------------------------------------
  
  InvalidMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvalidMsg& from);
  void MergeFrom(const InvalidMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 msg_type = 1;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 1;
  inline ::google::protobuf::int32 msg_type() const;
  inline void set_msg_type(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:dcmd_api.InvalidMsg)
 private:
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 msg_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_dcmd_5fagent_2eproto();
  friend void protobuf_AssignDesc_dcmd_5fagent_2eproto();
  friend void protobuf_ShutdownFile_dcmd_5fagent_2eproto();
  
  void InitAsDefaultInstance();
  static InvalidMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// AgentReport

// required string version = 1;
inline bool AgentReport::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentReport::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentReport::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentReport::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AgentReport::version() const {
  return *version_;
}
inline void AgentReport::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AgentReport::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AgentReport::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentReport::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AgentReport::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string agent_ips = 2;
inline int AgentReport::agent_ips_size() const {
  return agent_ips_.size();
}
inline void AgentReport::clear_agent_ips() {
  agent_ips_.Clear();
}
inline const ::std::string& AgentReport::agent_ips(int index) const {
  return agent_ips_.Get(index);
}
inline ::std::string* AgentReport::mutable_agent_ips(int index) {
  return agent_ips_.Mutable(index);
}
inline void AgentReport::set_agent_ips(int index, const ::std::string& value) {
  agent_ips_.Mutable(index)->assign(value);
}
inline void AgentReport::set_agent_ips(int index, const char* value) {
  agent_ips_.Mutable(index)->assign(value);
}
inline void AgentReport::set_agent_ips(int index, const char* value, size_t size) {
  agent_ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentReport::add_agent_ips() {
  return agent_ips_.Add();
}
inline void AgentReport::add_agent_ips(const ::std::string& value) {
  agent_ips_.Add()->assign(value);
}
inline void AgentReport::add_agent_ips(const char* value) {
  agent_ips_.Add()->assign(value);
}
inline void AgentReport::add_agent_ips(const char* value, size_t size) {
  agent_ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AgentReport::agent_ips() const {
  return agent_ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AgentReport::mutable_agent_ips() {
  return &agent_ips_;
}

// -------------------------------------------------------------------

// AgentReportReply

// required .dcmd_api.DcmdState state = 1;
inline bool AgentReportReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentReportReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentReportReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentReportReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState AgentReportReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void AgentReportReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional string err = 2;
inline bool AgentReportReply::has_err() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentReportReply::set_has_err() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentReportReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentReportReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& AgentReportReply::err() const {
  return *err_;
}
inline void AgentReportReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentReportReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentReportReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentReportReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* AgentReportReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 heatbeat = 3;
inline bool AgentReportReply::has_heatbeat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentReportReply::set_has_heatbeat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentReportReply::clear_has_heatbeat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentReportReply::clear_heatbeat() {
  heatbeat_ = 0;
  clear_has_heatbeat();
}
inline ::google::protobuf::int32 AgentReportReply::heatbeat() const {
  return heatbeat_;
}
inline void AgentReportReply::set_heatbeat(::google::protobuf::int32 value) {
  set_has_heatbeat();
  heatbeat_ = value;
}

// optional int32 package_size = 4;
inline bool AgentReportReply::has_package_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentReportReply::set_has_package_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentReportReply::clear_has_package_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentReportReply::clear_package_size() {
  package_size_ = 0;
  clear_has_package_size();
}
inline ::google::protobuf::int32 AgentReportReply::package_size() const {
  return package_size_;
}
inline void AgentReportReply::set_package_size(::google::protobuf::int32 value) {
  set_has_package_size();
  package_size_ = value;
}

// optional int32 opr_queue_threshold = 5;
inline bool AgentReportReply::has_opr_queue_threshold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AgentReportReply::set_has_opr_queue_threshold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AgentReportReply::clear_has_opr_queue_threshold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AgentReportReply::clear_opr_queue_threshold() {
  opr_queue_threshold_ = 0;
  clear_has_opr_queue_threshold();
}
inline ::google::protobuf::int32 AgentReportReply::opr_queue_threshold() const {
  return opr_queue_threshold_;
}
inline void AgentReportReply::set_opr_queue_threshold(::google::protobuf::int32 value) {
  set_has_opr_queue_threshold();
  opr_queue_threshold_ = value;
}

// optional int32 opr_overflow_threshold = 6;
inline bool AgentReportReply::has_opr_overflow_threshold() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AgentReportReply::set_has_opr_overflow_threshold() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AgentReportReply::clear_has_opr_overflow_threshold() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AgentReportReply::clear_opr_overflow_threshold() {
  opr_overflow_threshold_ = 0;
  clear_has_opr_overflow_threshold();
}
inline ::google::protobuf::int32 AgentReportReply::opr_overflow_threshold() const {
  return opr_overflow_threshold_;
}
inline void AgentReportReply::set_opr_overflow_threshold(::google::protobuf::int32 value) {
  set_has_opr_overflow_threshold();
  opr_overflow_threshold_ = value;
}

// -------------------------------------------------------------------

// AgentMasterNoticeReply

// repeated string cmd = 1;
inline int AgentMasterNoticeReply::cmd_size() const {
  return cmd_.size();
}
inline void AgentMasterNoticeReply::clear_cmd() {
  cmd_.Clear();
}
inline const ::std::string& AgentMasterNoticeReply::cmd(int index) const {
  return cmd_.Get(index);
}
inline ::std::string* AgentMasterNoticeReply::mutable_cmd(int index) {
  return cmd_.Mutable(index);
}
inline void AgentMasterNoticeReply::set_cmd(int index, const ::std::string& value) {
  cmd_.Mutable(index)->assign(value);
}
inline void AgentMasterNoticeReply::set_cmd(int index, const char* value) {
  cmd_.Mutable(index)->assign(value);
}
inline void AgentMasterNoticeReply::set_cmd(int index, const char* value, size_t size) {
  cmd_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentMasterNoticeReply::add_cmd() {
  return cmd_.Add();
}
inline void AgentMasterNoticeReply::add_cmd(const ::std::string& value) {
  cmd_.Add()->assign(value);
}
inline void AgentMasterNoticeReply::add_cmd(const char* value) {
  cmd_.Add()->assign(value);
}
inline void AgentMasterNoticeReply::add_cmd(const char* value, size_t size) {
  cmd_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AgentMasterNoticeReply::cmd() const {
  return cmd_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AgentMasterNoticeReply::mutable_cmd() {
  return &cmd_;
}

// repeated .dcmd_api.SubTaskProcess subtask_process = 2;
inline int AgentMasterNoticeReply::subtask_process_size() const {
  return subtask_process_.size();
}
inline void AgentMasterNoticeReply::clear_subtask_process() {
  subtask_process_.Clear();
}
inline const ::dcmd_api::SubTaskProcess& AgentMasterNoticeReply::subtask_process(int index) const {
  return subtask_process_.Get(index);
}
inline ::dcmd_api::SubTaskProcess* AgentMasterNoticeReply::mutable_subtask_process(int index) {
  return subtask_process_.Mutable(index);
}
inline ::dcmd_api::SubTaskProcess* AgentMasterNoticeReply::add_subtask_process() {
  return subtask_process_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskProcess >&
AgentMasterNoticeReply::subtask_process() const {
  return subtask_process_;
}
inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskProcess >*
AgentMasterNoticeReply::mutable_subtask_process() {
  return &subtask_process_;
}

// -------------------------------------------------------------------

// AgentTaskCmd

// required string cmd = 1;
inline bool AgentTaskCmd::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentTaskCmd::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentTaskCmd::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentTaskCmd::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& AgentTaskCmd::cmd() const {
  return *cmd_;
}
inline void AgentTaskCmd::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskCmd::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskCmd::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* AgentTaskCmd::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string task_cmd = 2;
inline bool AgentTaskCmd::has_task_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentTaskCmd::set_has_task_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentTaskCmd::clear_has_task_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentTaskCmd::clear_task_cmd() {
  if (task_cmd_ != &::google::protobuf::internal::kEmptyString) {
    task_cmd_->clear();
  }
  clear_has_task_cmd();
}
inline const ::std::string& AgentTaskCmd::task_cmd() const {
  return *task_cmd_;
}
inline void AgentTaskCmd::set_task_cmd(const ::std::string& value) {
  set_has_task_cmd();
  if (task_cmd_ == &::google::protobuf::internal::kEmptyString) {
    task_cmd_ = new ::std::string;
  }
  task_cmd_->assign(value);
}
inline void AgentTaskCmd::set_task_cmd(const char* value) {
  set_has_task_cmd();
  if (task_cmd_ == &::google::protobuf::internal::kEmptyString) {
    task_cmd_ = new ::std::string;
  }
  task_cmd_->assign(value);
}
inline void AgentTaskCmd::set_task_cmd(const char* value, size_t size) {
  set_has_task_cmd();
  if (task_cmd_ == &::google::protobuf::internal::kEmptyString) {
    task_cmd_ = new ::std::string;
  }
  task_cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_task_cmd() {
  set_has_task_cmd();
  if (task_cmd_ == &::google::protobuf::internal::kEmptyString) {
    task_cmd_ = new ::std::string;
  }
  return task_cmd_;
}
inline ::std::string* AgentTaskCmd::release_task_cmd() {
  clear_has_task_cmd();
  if (task_cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_cmd_;
    task_cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .dcmd_api.CmdType cmd_type = 3;
inline bool AgentTaskCmd::has_cmd_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentTaskCmd::set_has_cmd_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentTaskCmd::clear_has_cmd_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentTaskCmd::clear_cmd_type() {
  cmd_type_ = 0;
  clear_has_cmd_type();
}
inline dcmd_api::CmdType AgentTaskCmd::cmd_type() const {
  return static_cast< dcmd_api::CmdType >(cmd_type_);
}
inline void AgentTaskCmd::set_cmd_type(dcmd_api::CmdType value) {
  GOOGLE_DCHECK(dcmd_api::CmdType_IsValid(value));
  set_has_cmd_type();
  cmd_type_ = value;
}

// optional string task_id = 4;
inline bool AgentTaskCmd::has_task_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentTaskCmd::set_has_task_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentTaskCmd::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentTaskCmd::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& AgentTaskCmd::task_id() const {
  return *task_id_;
}
inline void AgentTaskCmd::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void AgentTaskCmd::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void AgentTaskCmd::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* AgentTaskCmd::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string subtask_id = 5;
inline bool AgentTaskCmd::has_subtask_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AgentTaskCmd::set_has_subtask_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AgentTaskCmd::clear_has_subtask_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AgentTaskCmd::clear_subtask_id() {
  if (subtask_id_ != &::google::protobuf::internal::kEmptyString) {
    subtask_id_->clear();
  }
  clear_has_subtask_id();
}
inline const ::std::string& AgentTaskCmd::subtask_id() const {
  return *subtask_id_;
}
inline void AgentTaskCmd::set_subtask_id(const ::std::string& value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentTaskCmd::set_subtask_id(const char* value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentTaskCmd::set_subtask_id(const char* value, size_t size) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_subtask_id() {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  return subtask_id_;
}
inline ::std::string* AgentTaskCmd::release_subtask_id() {
  clear_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtask_id_;
    subtask_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ip = 6;
inline bool AgentTaskCmd::has_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AgentTaskCmd::set_has_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AgentTaskCmd::clear_has_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AgentTaskCmd::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& AgentTaskCmd::ip() const {
  return *ip_;
}
inline void AgentTaskCmd::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentTaskCmd::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentTaskCmd::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* AgentTaskCmd::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string svr_name = 7;
inline bool AgentTaskCmd::has_svr_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AgentTaskCmd::set_has_svr_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AgentTaskCmd::clear_has_svr_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AgentTaskCmd::clear_svr_name() {
  if (svr_name_ != &::google::protobuf::internal::kEmptyString) {
    svr_name_->clear();
  }
  clear_has_svr_name();
}
inline const ::std::string& AgentTaskCmd::svr_name() const {
  return *svr_name_;
}
inline void AgentTaskCmd::set_svr_name(const ::std::string& value) {
  set_has_svr_name();
  if (svr_name_ == &::google::protobuf::internal::kEmptyString) {
    svr_name_ = new ::std::string;
  }
  svr_name_->assign(value);
}
inline void AgentTaskCmd::set_svr_name(const char* value) {
  set_has_svr_name();
  if (svr_name_ == &::google::protobuf::internal::kEmptyString) {
    svr_name_ = new ::std::string;
  }
  svr_name_->assign(value);
}
inline void AgentTaskCmd::set_svr_name(const char* value, size_t size) {
  set_has_svr_name();
  if (svr_name_ == &::google::protobuf::internal::kEmptyString) {
    svr_name_ = new ::std::string;
  }
  svr_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_svr_name() {
  set_has_svr_name();
  if (svr_name_ == &::google::protobuf::internal::kEmptyString) {
    svr_name_ = new ::std::string;
  }
  return svr_name_;
}
inline ::std::string* AgentTaskCmd::release_svr_name() {
  clear_has_svr_name();
  if (svr_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svr_name_;
    svr_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string svr_pool = 8;
inline bool AgentTaskCmd::has_svr_pool() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AgentTaskCmd::set_has_svr_pool() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AgentTaskCmd::clear_has_svr_pool() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AgentTaskCmd::clear_svr_pool() {
  if (svr_pool_ != &::google::protobuf::internal::kEmptyString) {
    svr_pool_->clear();
  }
  clear_has_svr_pool();
}
inline const ::std::string& AgentTaskCmd::svr_pool() const {
  return *svr_pool_;
}
inline void AgentTaskCmd::set_svr_pool(const ::std::string& value) {
  set_has_svr_pool();
  if (svr_pool_ == &::google::protobuf::internal::kEmptyString) {
    svr_pool_ = new ::std::string;
  }
  svr_pool_->assign(value);
}
inline void AgentTaskCmd::set_svr_pool(const char* value) {
  set_has_svr_pool();
  if (svr_pool_ == &::google::protobuf::internal::kEmptyString) {
    svr_pool_ = new ::std::string;
  }
  svr_pool_->assign(value);
}
inline void AgentTaskCmd::set_svr_pool(const char* value, size_t size) {
  set_has_svr_pool();
  if (svr_pool_ == &::google::protobuf::internal::kEmptyString) {
    svr_pool_ = new ::std::string;
  }
  svr_pool_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_svr_pool() {
  set_has_svr_pool();
  if (svr_pool_ == &::google::protobuf::internal::kEmptyString) {
    svr_pool_ = new ::std::string;
  }
  return svr_pool_;
}
inline ::std::string* AgentTaskCmd::release_svr_pool() {
  clear_has_svr_pool();
  if (svr_pool_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svr_pool_;
    svr_pool_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string svr_ver = 9;
inline bool AgentTaskCmd::has_svr_ver() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AgentTaskCmd::set_has_svr_ver() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AgentTaskCmd::clear_has_svr_ver() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AgentTaskCmd::clear_svr_ver() {
  if (svr_ver_ != &::google::protobuf::internal::kEmptyString) {
    svr_ver_->clear();
  }
  clear_has_svr_ver();
}
inline const ::std::string& AgentTaskCmd::svr_ver() const {
  return *svr_ver_;
}
inline void AgentTaskCmd::set_svr_ver(const ::std::string& value) {
  set_has_svr_ver();
  if (svr_ver_ == &::google::protobuf::internal::kEmptyString) {
    svr_ver_ = new ::std::string;
  }
  svr_ver_->assign(value);
}
inline void AgentTaskCmd::set_svr_ver(const char* value) {
  set_has_svr_ver();
  if (svr_ver_ == &::google::protobuf::internal::kEmptyString) {
    svr_ver_ = new ::std::string;
  }
  svr_ver_->assign(value);
}
inline void AgentTaskCmd::set_svr_ver(const char* value, size_t size) {
  set_has_svr_ver();
  if (svr_ver_ == &::google::protobuf::internal::kEmptyString) {
    svr_ver_ = new ::std::string;
  }
  svr_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_svr_ver() {
  set_has_svr_ver();
  if (svr_ver_ == &::google::protobuf::internal::kEmptyString) {
    svr_ver_ = new ::std::string;
  }
  return svr_ver_;
}
inline ::std::string* AgentTaskCmd::release_svr_ver() {
  clear_has_svr_ver();
  if (svr_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svr_ver_;
    svr_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string svr_repo = 10;
inline bool AgentTaskCmd::has_svr_repo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AgentTaskCmd::set_has_svr_repo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AgentTaskCmd::clear_has_svr_repo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AgentTaskCmd::clear_svr_repo() {
  if (svr_repo_ != &::google::protobuf::internal::kEmptyString) {
    svr_repo_->clear();
  }
  clear_has_svr_repo();
}
inline const ::std::string& AgentTaskCmd::svr_repo() const {
  return *svr_repo_;
}
inline void AgentTaskCmd::set_svr_repo(const ::std::string& value) {
  set_has_svr_repo();
  if (svr_repo_ == &::google::protobuf::internal::kEmptyString) {
    svr_repo_ = new ::std::string;
  }
  svr_repo_->assign(value);
}
inline void AgentTaskCmd::set_svr_repo(const char* value) {
  set_has_svr_repo();
  if (svr_repo_ == &::google::protobuf::internal::kEmptyString) {
    svr_repo_ = new ::std::string;
  }
  svr_repo_->assign(value);
}
inline void AgentTaskCmd::set_svr_repo(const char* value, size_t size) {
  set_has_svr_repo();
  if (svr_repo_ == &::google::protobuf::internal::kEmptyString) {
    svr_repo_ = new ::std::string;
  }
  svr_repo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_svr_repo() {
  set_has_svr_repo();
  if (svr_repo_ == &::google::protobuf::internal::kEmptyString) {
    svr_repo_ = new ::std::string;
  }
  return svr_repo_;
}
inline ::std::string* AgentTaskCmd::release_svr_repo() {
  clear_has_svr_repo();
  if (svr_repo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svr_repo_;
    svr_repo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string svr_user = 11;
inline bool AgentTaskCmd::has_svr_user() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AgentTaskCmd::set_has_svr_user() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AgentTaskCmd::clear_has_svr_user() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AgentTaskCmd::clear_svr_user() {
  if (svr_user_ != &::google::protobuf::internal::kEmptyString) {
    svr_user_->clear();
  }
  clear_has_svr_user();
}
inline const ::std::string& AgentTaskCmd::svr_user() const {
  return *svr_user_;
}
inline void AgentTaskCmd::set_svr_user(const ::std::string& value) {
  set_has_svr_user();
  if (svr_user_ == &::google::protobuf::internal::kEmptyString) {
    svr_user_ = new ::std::string;
  }
  svr_user_->assign(value);
}
inline void AgentTaskCmd::set_svr_user(const char* value) {
  set_has_svr_user();
  if (svr_user_ == &::google::protobuf::internal::kEmptyString) {
    svr_user_ = new ::std::string;
  }
  svr_user_->assign(value);
}
inline void AgentTaskCmd::set_svr_user(const char* value, size_t size) {
  set_has_svr_user();
  if (svr_user_ == &::google::protobuf::internal::kEmptyString) {
    svr_user_ = new ::std::string;
  }
  svr_user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_svr_user() {
  set_has_svr_user();
  if (svr_user_ == &::google::protobuf::internal::kEmptyString) {
    svr_user_ = new ::std::string;
  }
  return svr_user_;
}
inline ::std::string* AgentTaskCmd::release_svr_user() {
  clear_has_svr_user();
  if (svr_user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svr_user_;
    svr_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string svr_env_ver = 12;
inline bool AgentTaskCmd::has_svr_env_ver() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AgentTaskCmd::set_has_svr_env_ver() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AgentTaskCmd::clear_has_svr_env_ver() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AgentTaskCmd::clear_svr_env_ver() {
  if (svr_env_ver_ != &::google::protobuf::internal::kEmptyString) {
    svr_env_ver_->clear();
  }
  clear_has_svr_env_ver();
}
inline const ::std::string& AgentTaskCmd::svr_env_ver() const {
  return *svr_env_ver_;
}
inline void AgentTaskCmd::set_svr_env_ver(const ::std::string& value) {
  set_has_svr_env_ver();
  if (svr_env_ver_ == &::google::protobuf::internal::kEmptyString) {
    svr_env_ver_ = new ::std::string;
  }
  svr_env_ver_->assign(value);
}
inline void AgentTaskCmd::set_svr_env_ver(const char* value) {
  set_has_svr_env_ver();
  if (svr_env_ver_ == &::google::protobuf::internal::kEmptyString) {
    svr_env_ver_ = new ::std::string;
  }
  svr_env_ver_->assign(value);
}
inline void AgentTaskCmd::set_svr_env_ver(const char* value, size_t size) {
  set_has_svr_env_ver();
  if (svr_env_ver_ == &::google::protobuf::internal::kEmptyString) {
    svr_env_ver_ = new ::std::string;
  }
  svr_env_ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_svr_env_ver() {
  set_has_svr_env_ver();
  if (svr_env_ver_ == &::google::protobuf::internal::kEmptyString) {
    svr_env_ver_ = new ::std::string;
  }
  return svr_env_ver_;
}
inline ::std::string* AgentTaskCmd::release_svr_env_ver() {
  clear_has_svr_env_ver();
  if (svr_env_ver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svr_env_ver_;
    svr_env_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool update_env = 13;
inline bool AgentTaskCmd::has_update_env() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AgentTaskCmd::set_has_update_env() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AgentTaskCmd::clear_has_update_env() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AgentTaskCmd::clear_update_env() {
  update_env_ = false;
  clear_has_update_env();
}
inline bool AgentTaskCmd::update_env() const {
  return update_env_;
}
inline void AgentTaskCmd::set_update_env(bool value) {
  set_has_update_env();
  update_env_ = value;
}

// optional bool update_ver = 14;
inline bool AgentTaskCmd::has_update_ver() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AgentTaskCmd::set_has_update_ver() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AgentTaskCmd::clear_has_update_ver() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AgentTaskCmd::clear_update_ver() {
  update_ver_ = false;
  clear_has_update_ver();
}
inline bool AgentTaskCmd::update_ver() const {
  return update_ver_;
}
inline void AgentTaskCmd::set_update_ver(bool value) {
  set_has_update_ver();
  update_ver_ = value;
}

// optional bool output_process = 15;
inline bool AgentTaskCmd::has_output_process() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AgentTaskCmd::set_has_output_process() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AgentTaskCmd::clear_has_output_process() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AgentTaskCmd::clear_output_process() {
  output_process_ = false;
  clear_has_output_process();
}
inline bool AgentTaskCmd::output_process() const {
  return output_process_;
}
inline void AgentTaskCmd::set_output_process(bool value) {
  set_has_output_process();
  output_process_ = value;
}

// optional string script = 16;
inline bool AgentTaskCmd::has_script() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AgentTaskCmd::set_has_script() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AgentTaskCmd::clear_has_script() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AgentTaskCmd::clear_script() {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& AgentTaskCmd::script() const {
  return *script_;
}
inline void AgentTaskCmd::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void AgentTaskCmd::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void AgentTaskCmd::set_script(const char* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmd::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  return script_;
}
inline ::std::string* AgentTaskCmd::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .dcmd_api.KeyValue task_arg = 17;
inline int AgentTaskCmd::task_arg_size() const {
  return task_arg_.size();
}
inline void AgentTaskCmd::clear_task_arg() {
  task_arg_.Clear();
}
inline const ::dcmd_api::KeyValue& AgentTaskCmd::task_arg(int index) const {
  return task_arg_.Get(index);
}
inline ::dcmd_api::KeyValue* AgentTaskCmd::mutable_task_arg(int index) {
  return task_arg_.Mutable(index);
}
inline ::dcmd_api::KeyValue* AgentTaskCmd::add_task_arg() {
  return task_arg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >&
AgentTaskCmd::task_arg() const {
  return task_arg_;
}
inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >*
AgentTaskCmd::mutable_task_arg() {
  return &task_arg_;
}

// -------------------------------------------------------------------

// AgentTaskCmdReply

// required string cmd = 1;
inline bool AgentTaskCmdReply::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentTaskCmdReply::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentTaskCmdReply::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentTaskCmdReply::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& AgentTaskCmdReply::cmd() const {
  return *cmd_;
}
inline void AgentTaskCmdReply::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskCmdReply::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskCmdReply::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskCmdReply::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* AgentTaskCmdReply::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentSubTaskProcess

// required string task_id = 1;
inline bool AgentSubTaskProcess::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentSubTaskProcess::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentSubTaskProcess::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentSubTaskProcess::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& AgentSubTaskProcess::task_id() const {
  return *task_id_;
}
inline void AgentSubTaskProcess::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void AgentSubTaskProcess::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void AgentSubTaskProcess::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentSubTaskProcess::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* AgentSubTaskProcess::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string subtask_id = 2;
inline bool AgentSubTaskProcess::has_subtask_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentSubTaskProcess::set_has_subtask_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentSubTaskProcess::clear_has_subtask_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentSubTaskProcess::clear_subtask_id() {
  if (subtask_id_ != &::google::protobuf::internal::kEmptyString) {
    subtask_id_->clear();
  }
  clear_has_subtask_id();
}
inline const ::std::string& AgentSubTaskProcess::subtask_id() const {
  return *subtask_id_;
}
inline void AgentSubTaskProcess::set_subtask_id(const ::std::string& value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentSubTaskProcess::set_subtask_id(const char* value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentSubTaskProcess::set_subtask_id(const char* value, size_t size) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentSubTaskProcess::mutable_subtask_id() {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  return subtask_id_;
}
inline ::std::string* AgentSubTaskProcess::release_subtask_id() {
  clear_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtask_id_;
    subtask_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string process = 3;
inline bool AgentSubTaskProcess::has_process() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentSubTaskProcess::set_has_process() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentSubTaskProcess::clear_has_process() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentSubTaskProcess::clear_process() {
  if (process_ != &::google::protobuf::internal::kEmptyString) {
    process_->clear();
  }
  clear_has_process();
}
inline const ::std::string& AgentSubTaskProcess::process() const {
  return *process_;
}
inline void AgentSubTaskProcess::set_process(const ::std::string& value) {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  process_->assign(value);
}
inline void AgentSubTaskProcess::set_process(const char* value) {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  process_->assign(value);
}
inline void AgentSubTaskProcess::set_process(const char* value, size_t size) {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  process_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentSubTaskProcess::mutable_process() {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  return process_;
}
inline ::std::string* AgentSubTaskProcess::release_process() {
  clear_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = process_;
    process_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentTaskResult

// required string cmd = 1;
inline bool AgentTaskResult::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentTaskResult::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentTaskResult::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentTaskResult::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& AgentTaskResult::cmd() const {
  return *cmd_;
}
inline void AgentTaskResult::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskResult::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskResult::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskResult::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* AgentTaskResult::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string task_id = 2;
inline bool AgentTaskResult::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentTaskResult::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentTaskResult::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentTaskResult::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& AgentTaskResult::task_id() const {
  return *task_id_;
}
inline void AgentTaskResult::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void AgentTaskResult::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void AgentTaskResult::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskResult::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* AgentTaskResult::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string subtask_id = 3;
inline bool AgentTaskResult::has_subtask_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentTaskResult::set_has_subtask_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentTaskResult::clear_has_subtask_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentTaskResult::clear_subtask_id() {
  if (subtask_id_ != &::google::protobuf::internal::kEmptyString) {
    subtask_id_->clear();
  }
  clear_has_subtask_id();
}
inline const ::std::string& AgentTaskResult::subtask_id() const {
  return *subtask_id_;
}
inline void AgentTaskResult::set_subtask_id(const ::std::string& value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentTaskResult::set_subtask_id(const char* value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentTaskResult::set_subtask_id(const char* value, size_t size) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskResult::mutable_subtask_id() {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  return subtask_id_;
}
inline ::std::string* AgentTaskResult::release_subtask_id() {
  clear_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtask_id_;
    subtask_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool success = 4;
inline bool AgentTaskResult::has_success() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentTaskResult::set_has_success() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentTaskResult::clear_has_success() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentTaskResult::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool AgentTaskResult::success() const {
  return success_;
}
inline void AgentTaskResult::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional string err = 5;
inline bool AgentTaskResult::has_err() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AgentTaskResult::set_has_err() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AgentTaskResult::clear_has_err() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AgentTaskResult::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& AgentTaskResult::err() const {
  return *err_;
}
inline void AgentTaskResult::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentTaskResult::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentTaskResult::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskResult::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* AgentTaskResult::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string process = 6;
inline bool AgentTaskResult::has_process() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AgentTaskResult::set_has_process() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AgentTaskResult::clear_has_process() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AgentTaskResult::clear_process() {
  if (process_ != &::google::protobuf::internal::kEmptyString) {
    process_->clear();
  }
  clear_has_process();
}
inline const ::std::string& AgentTaskResult::process() const {
  return *process_;
}
inline void AgentTaskResult::set_process(const ::std::string& value) {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  process_->assign(value);
}
inline void AgentTaskResult::set_process(const char* value) {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  process_->assign(value);
}
inline void AgentTaskResult::set_process(const char* value, size_t size) {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  process_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskResult::mutable_process() {
  set_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    process_ = new ::std::string;
  }
  return process_;
}
inline ::std::string* AgentTaskResult::release_process() {
  clear_has_process();
  if (process_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = process_;
    process_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentTaskResultReply

// required string cmd = 1;
inline bool AgentTaskResultReply::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentTaskResultReply::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentTaskResultReply::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentTaskResultReply::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& AgentTaskResultReply::cmd() const {
  return *cmd_;
}
inline void AgentTaskResultReply::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskResultReply::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void AgentTaskResultReply::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskResultReply::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* AgentTaskResultReply::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentOprCmd

// required string opr_id = 1;
inline bool AgentOprCmd::has_opr_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentOprCmd::set_has_opr_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentOprCmd::clear_has_opr_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentOprCmd::clear_opr_id() {
  if (opr_id_ != &::google::protobuf::internal::kEmptyString) {
    opr_id_->clear();
  }
  clear_has_opr_id();
}
inline const ::std::string& AgentOprCmd::opr_id() const {
  return *opr_id_;
}
inline void AgentOprCmd::set_opr_id(const ::std::string& value) {
  set_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    opr_id_ = new ::std::string;
  }
  opr_id_->assign(value);
}
inline void AgentOprCmd::set_opr_id(const char* value) {
  set_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    opr_id_ = new ::std::string;
  }
  opr_id_->assign(value);
}
inline void AgentOprCmd::set_opr_id(const char* value, size_t size) {
  set_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    opr_id_ = new ::std::string;
  }
  opr_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentOprCmd::mutable_opr_id() {
  set_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    opr_id_ = new ::std::string;
  }
  return opr_id_;
}
inline ::std::string* AgentOprCmd::release_opr_id() {
  clear_has_opr_id();
  if (opr_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opr_id_;
    opr_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool AgentOprCmd::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentOprCmd::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentOprCmd::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentOprCmd::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AgentOprCmd::name() const {
  return *name_;
}
inline void AgentOprCmd::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AgentOprCmd::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AgentOprCmd::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentOprCmd::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AgentOprCmd::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string run_user = 3;
inline bool AgentOprCmd::has_run_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentOprCmd::set_has_run_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentOprCmd::clear_has_run_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentOprCmd::clear_run_user() {
  if (run_user_ != &::google::protobuf::internal::kEmptyString) {
    run_user_->clear();
  }
  clear_has_run_user();
}
inline const ::std::string& AgentOprCmd::run_user() const {
  return *run_user_;
}
inline void AgentOprCmd::set_run_user(const ::std::string& value) {
  set_has_run_user();
  if (run_user_ == &::google::protobuf::internal::kEmptyString) {
    run_user_ = new ::std::string;
  }
  run_user_->assign(value);
}
inline void AgentOprCmd::set_run_user(const char* value) {
  set_has_run_user();
  if (run_user_ == &::google::protobuf::internal::kEmptyString) {
    run_user_ = new ::std::string;
  }
  run_user_->assign(value);
}
inline void AgentOprCmd::set_run_user(const char* value, size_t size) {
  set_has_run_user();
  if (run_user_ == &::google::protobuf::internal::kEmptyString) {
    run_user_ = new ::std::string;
  }
  run_user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentOprCmd::mutable_run_user() {
  set_has_run_user();
  if (run_user_ == &::google::protobuf::internal::kEmptyString) {
    run_user_ = new ::std::string;
  }
  return run_user_;
}
inline ::std::string* AgentOprCmd::release_run_user() {
  clear_has_run_user();
  if (run_user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = run_user_;
    run_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 timeout = 4;
inline bool AgentOprCmd::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentOprCmd::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentOprCmd::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentOprCmd::clear_timeout() {
  timeout_ = 0;
  clear_has_timeout();
}
inline ::google::protobuf::int32 AgentOprCmd::timeout() const {
  return timeout_;
}
inline void AgentOprCmd::set_timeout(::google::protobuf::int32 value) {
  set_has_timeout();
  timeout_ = value;
}

// required string script = 5;
inline bool AgentOprCmd::has_script() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AgentOprCmd::set_has_script() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AgentOprCmd::clear_has_script() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AgentOprCmd::clear_script() {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& AgentOprCmd::script() const {
  return *script_;
}
inline void AgentOprCmd::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void AgentOprCmd::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void AgentOprCmd::set_script(const char* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentOprCmd::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  return script_;
}
inline ::std::string* AgentOprCmd::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .dcmd_api.KeyValue args = 6;
inline int AgentOprCmd::args_size() const {
  return args_.size();
}
inline void AgentOprCmd::clear_args() {
  args_.Clear();
}
inline const ::dcmd_api::KeyValue& AgentOprCmd::args(int index) const {
  return args_.Get(index);
}
inline ::dcmd_api::KeyValue* AgentOprCmd::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::dcmd_api::KeyValue* AgentOprCmd::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >&
AgentOprCmd::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::KeyValue >*
AgentOprCmd::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// AgentTaskOutput

// required string subtask_id = 1;
inline bool AgentTaskOutput::has_subtask_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentTaskOutput::set_has_subtask_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentTaskOutput::clear_has_subtask_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentTaskOutput::clear_subtask_id() {
  if (subtask_id_ != &::google::protobuf::internal::kEmptyString) {
    subtask_id_->clear();
  }
  clear_has_subtask_id();
}
inline const ::std::string& AgentTaskOutput::subtask_id() const {
  return *subtask_id_;
}
inline void AgentTaskOutput::set_subtask_id(const ::std::string& value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentTaskOutput::set_subtask_id(const char* value) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(value);
}
inline void AgentTaskOutput::set_subtask_id(const char* value, size_t size) {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  subtask_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskOutput::mutable_subtask_id() {
  set_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    subtask_id_ = new ::std::string;
  }
  return subtask_id_;
}
inline ::std::string* AgentTaskOutput::release_subtask_id() {
  clear_has_subtask_id();
  if (subtask_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtask_id_;
    subtask_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 offset = 2;
inline bool AgentTaskOutput::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentTaskOutput::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentTaskOutput::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentTaskOutput::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 AgentTaskOutput::offset() const {
  return offset_;
}
inline void AgentTaskOutput::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// optional string ip = 3;
inline bool AgentTaskOutput::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentTaskOutput::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentTaskOutput::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentTaskOutput::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& AgentTaskOutput::ip() const {
  return *ip_;
}
inline void AgentTaskOutput::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentTaskOutput::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentTaskOutput::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskOutput::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* AgentTaskOutput::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentTaskOutputReply

// required .dcmd_api.DcmdState state = 1;
inline bool AgentTaskOutputReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentTaskOutputReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentTaskOutputReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentTaskOutputReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState AgentTaskOutputReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void AgentTaskOutputReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// required string result = 2;
inline bool AgentTaskOutputReply::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentTaskOutputReply::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentTaskOutputReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentTaskOutputReply::clear_result() {
  if (result_ != &::google::protobuf::internal::kEmptyString) {
    result_->clear();
  }
  clear_has_result();
}
inline const ::std::string& AgentTaskOutputReply::result() const {
  return *result_;
}
inline void AgentTaskOutputReply::set_result(const ::std::string& value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void AgentTaskOutputReply::set_result(const char* value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void AgentTaskOutputReply::set_result(const char* value, size_t size) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskOutputReply::mutable_result() {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  return result_;
}
inline ::std::string* AgentTaskOutputReply::release_result() {
  clear_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_;
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 offset = 3;
inline bool AgentTaskOutputReply::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentTaskOutputReply::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentTaskOutputReply::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentTaskOutputReply::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 AgentTaskOutputReply::offset() const {
  return offset_;
}
inline void AgentTaskOutputReply::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// optional string err = 4;
inline bool AgentTaskOutputReply::has_err() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentTaskOutputReply::set_has_err() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentTaskOutputReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentTaskOutputReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& AgentTaskOutputReply::err() const {
  return *err_;
}
inline void AgentTaskOutputReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentTaskOutputReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentTaskOutputReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentTaskOutputReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* AgentTaskOutputReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentRunningTask

// optional string ip = 1;
inline bool AgentRunningTask::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentRunningTask::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentRunningTask::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentRunningTask::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& AgentRunningTask::ip() const {
  return *ip_;
}
inline void AgentRunningTask::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentRunningTask::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentRunningTask::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentRunningTask::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* AgentRunningTask::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string svr_name = 2;
inline bool AgentRunningTask::has_svr_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentRunningTask::set_has_svr_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentRunningTask::clear_has_svr_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentRunningTask::clear_svr_name() {
  if (svr_name_ != &::google::protobuf::internal::kEmptyString) {
    svr_name_->clear();
  }
  clear_has_svr_name();
}
inline const ::std::string& AgentRunningTask::svr_name() const {
  return *svr_name_;
}
inline void AgentRunningTask::set_svr_name(const ::std::string& value) {
  set_has_svr_name();
  if (svr_name_ == &::google::protobuf::internal::kEmptyString) {
    svr_name_ = new ::std::string;
  }
  svr_name_->assign(value);
}
inline void AgentRunningTask::set_svr_name(const char* value) {
  set_has_svr_name();
  if (svr_name_ == &::google::protobuf::internal::kEmptyString) {
    svr_name_ = new ::std::string;
  }
  svr_name_->assign(value);
}
inline void AgentRunningTask::set_svr_name(const char* value, size_t size) {
  set_has_svr_name();
  if (svr_name_ == &::google::protobuf::internal::kEmptyString) {
    svr_name_ = new ::std::string;
  }
  svr_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentRunningTask::mutable_svr_name() {
  set_has_svr_name();
  if (svr_name_ == &::google::protobuf::internal::kEmptyString) {
    svr_name_ = new ::std::string;
  }
  return svr_name_;
}
inline ::std::string* AgentRunningTask::release_svr_name() {
  clear_has_svr_name();
  if (svr_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svr_name_;
    svr_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentRunningTaskReply

// required .dcmd_api.DcmdState state = 1;
inline bool AgentRunningTaskReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentRunningTaskReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentRunningTaskReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentRunningTaskReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState AgentRunningTaskReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void AgentRunningTaskReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// repeated .dcmd_api.SubTaskInfo result = 2;
inline int AgentRunningTaskReply::result_size() const {
  return result_.size();
}
inline void AgentRunningTaskReply::clear_result() {
  result_.Clear();
}
inline const ::dcmd_api::SubTaskInfo& AgentRunningTaskReply::result(int index) const {
  return result_.Get(index);
}
inline ::dcmd_api::SubTaskInfo* AgentRunningTaskReply::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::dcmd_api::SubTaskInfo* AgentRunningTaskReply::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo >&
AgentRunningTaskReply::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::SubTaskInfo >*
AgentRunningTaskReply::mutable_result() {
  return &result_;
}

// optional string err = 3;
inline bool AgentRunningTaskReply::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentRunningTaskReply::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentRunningTaskReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentRunningTaskReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& AgentRunningTaskReply::err() const {
  return *err_;
}
inline void AgentRunningTaskReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentRunningTaskReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentRunningTaskReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentRunningTaskReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* AgentRunningTaskReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentRunningOpr

// optional string ip = 1;
inline bool AgentRunningOpr::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentRunningOpr::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentRunningOpr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentRunningOpr::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& AgentRunningOpr::ip() const {
  return *ip_;
}
inline void AgentRunningOpr::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentRunningOpr::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AgentRunningOpr::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentRunningOpr::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* AgentRunningOpr::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AgentRunningOprReply

// required .dcmd_api.DcmdState state = 1;
inline bool AgentRunningOprReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentRunningOprReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentRunningOprReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentRunningOprReply::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline dcmd_api::DcmdState AgentRunningOprReply::state() const {
  return static_cast< dcmd_api::DcmdState >(state_);
}
inline void AgentRunningOprReply::set_state(dcmd_api::DcmdState value) {
  GOOGLE_DCHECK(dcmd_api::DcmdState_IsValid(value));
  set_has_state();
  state_ = value;
}

// repeated .dcmd_api.OprInfo result = 2;
inline int AgentRunningOprReply::result_size() const {
  return result_.size();
}
inline void AgentRunningOprReply::clear_result() {
  result_.Clear();
}
inline const ::dcmd_api::OprInfo& AgentRunningOprReply::result(int index) const {
  return result_.Get(index);
}
inline ::dcmd_api::OprInfo* AgentRunningOprReply::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::dcmd_api::OprInfo* AgentRunningOprReply::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo >&
AgentRunningOprReply::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::dcmd_api::OprInfo >*
AgentRunningOprReply::mutable_result() {
  return &result_;
}

// optional string err = 3;
inline bool AgentRunningOprReply::has_err() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentRunningOprReply::set_has_err() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentRunningOprReply::clear_has_err() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentRunningOprReply::clear_err() {
  if (err_ != &::google::protobuf::internal::kEmptyString) {
    err_->clear();
  }
  clear_has_err();
}
inline const ::std::string& AgentRunningOprReply::err() const {
  return *err_;
}
inline void AgentRunningOprReply::set_err(const ::std::string& value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentRunningOprReply::set_err(const char* value) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(value);
}
inline void AgentRunningOprReply::set_err(const char* value, size_t size) {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  err_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentRunningOprReply::mutable_err() {
  set_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    err_ = new ::std::string;
  }
  return err_;
}
inline ::std::string* AgentRunningOprReply::release_err() {
  clear_has_err();
  if (err_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_;
    err_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// InvalidMsg

// required int32 msg_type = 1;
inline bool InvalidMsg::has_msg_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvalidMsg::set_has_msg_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvalidMsg::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvalidMsg::clear_msg_type() {
  msg_type_ = 0;
  clear_has_msg_type();
}
inline ::google::protobuf::int32 InvalidMsg::msg_type() const {
  return msg_type_;
}
inline void InvalidMsg::set_msg_type(::google::protobuf::int32 value) {
  set_has_msg_type();
  msg_type_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dcmd_api

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dcmd_5fagent_2eproto__INCLUDED
